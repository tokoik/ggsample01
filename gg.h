#pragma once

/*!

@mainpage ゲームグラフィックス特論の宿題用補助プログラム GLFW3 版.

@copyright Copyright (c) 2011-2022 Kohe Tokoi. All Rights Reserved.

Permission is hereby granted, free of charge,  to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction,  including without limitation the rights
to use, copy,  modify, merge,  publish, distribute,  sublicense,  and/or sell
copies or substantial portions of the Software.

The above  copyright notice  and this permission notice  shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS IS",  WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO THE WARRANTIES  OF MERCHANTABILITY,
FITNESS  FOR  A PARTICULAR PURPOSE  AND NONINFRINGEMENT.  IN  NO EVENT  SHALL
KOHE TOKOI  BE LIABLE FOR ANY CLAIM,  DAMAGES OR OTHER LIABILITY,  WHETHER IN
AN ACTION  OF CONTRACT,  TORT  OR  OTHERWISE,  ARISING  FROM,  OUT OF  OR  IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

///
/// ゲームグラフィックス特論の宿題用補助プログラム GLFW3 版の宣言.
///
/// @file
/// @author Kohe Tokoi
/// @date March 31, 2021
///

/// @cond INCLUDE_OPENGL_FUNCTIONS

// macOS で "OpenGL deprecated の警告を出さない
#if defined(__APPLE__)
#  define GL_SILENCE_DEPRECATION
#endif

// フレームワークに GLFW 3 を使う
#if defined(IMGUI_IMPL_OPENGL_ES2)
#  define GLFW_INCLUDE_ES2
#elif defined(IMGUI_IMPL_OPENGL_ES3)
#  define GLFW_INCLUDE_ES3
#else
#  define GLFW_INCLUDE_GLCOREARB
#endif
#include <GLFW/glfw3.h>

// 標準ライブラリ
#include <cmath>
#include <array>
#include <vector>
#include <string>
#include <memory>

// Windows (Visual Studio) のとき
#if defined(_MSC_VER)
// 非推奨の警告を出さない
#  pragma warning(disable:4996)
// 数学ライブラリの定数を使う
#  define _USE_MATH_DEFINES
// MIN() / MAX マクロは使わない
#  define NOMINMAX
// APIENTRY マクロは使わない
#  undef APIENTRY
// ファイルパスの文字コード
#include <atlstr.h>
using pathString = CString;
using pathChar = wchar_t;
extern pathString Utf8ToTChar(const std::string& string);
extern std::string TCharToUtf8(const pathString& cstring);
// デバッグビルドかどうか調べる
#  if defined(_DEBUG)
#    if !defined(DEBUG)
#      define DEBUG
#    endif
#    define GLFW3_CONFIGURATION "Debug"
#  else
#    if !defined(NDEBUG)
#      define NDEBUG
#    endif
#    define GLFW3_CONFIGURATION "Release"
#  endif
// プラットフォームを調べる
#  if defined(_WIN64)
#    define GLFW3_PLATFORM "x64"
#  else
#    define GLFW3_PLATFORM "Win32"
#  endif
#else
// ファイルパスの文字コード
using pathString = std::string;
using pathChar = char;
inline pathString Utf8ToTChar(const std::string& string) { return string; }
inline std::string TCharToUtf8(const pathString& cstring) { return cstring; }
#endif

// OpenGL 3.2 の API のエントリポイント
#if !defined(GL3_PROTOTYPES) && !defined(GL_GLES_PROTOTYPES)
extern PFNGLACTIVEPROGRAMEXTPROC glActiveProgramEXT;
extern PFNGLACTIVESHADERPROGRAMPROC glActiveShaderProgram;
extern PFNGLACTIVETEXTUREPROC glActiveTexture;
extern PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC glApplyFramebufferAttachmentCMAAINTEL;
extern PFNGLATTACHSHADERPROC glAttachShader;
extern PFNGLBEGINCONDITIONALRENDERNVPROC glBeginConditionalRenderNV;
extern PFNGLBEGINCONDITIONALRENDERPROC glBeginConditionalRender;
extern PFNGLBEGINPERFMONITORAMDPROC glBeginPerfMonitorAMD;
extern PFNGLBEGINPERFQUERYINTELPROC glBeginPerfQueryINTEL;
extern PFNGLBEGINQUERYINDEXEDPROC glBeginQueryIndexed;
extern PFNGLBEGINQUERYPROC glBeginQuery;
extern PFNGLBEGINTRANSFORMFEEDBACKPROC glBeginTransformFeedback;
extern PFNGLBINDATTRIBLOCATIONPROC glBindAttribLocation;
extern PFNGLBINDBUFFERBASEPROC glBindBufferBase;
extern PFNGLBINDBUFFERPROC glBindBuffer;
extern PFNGLBINDBUFFERRANGEPROC glBindBufferRange;
extern PFNGLBINDBUFFERSBASEPROC glBindBuffersBase;
extern PFNGLBINDBUFFERSRANGEPROC glBindBuffersRange;
extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glBindFragDataLocationIndexed;
extern PFNGLBINDFRAGDATALOCATIONPROC glBindFragDataLocation;
extern PFNGLBINDFRAMEBUFFERPROC glBindFramebuffer;
extern PFNGLBINDIMAGETEXTUREPROC glBindImageTexture;
extern PFNGLBINDIMAGETEXTURESPROC glBindImageTextures;
extern PFNGLBINDMULTITEXTUREEXTPROC glBindMultiTextureEXT;
extern PFNGLBINDPROGRAMPIPELINEPROC glBindProgramPipeline;
extern PFNGLBINDRENDERBUFFERPROC glBindRenderbuffer;
extern PFNGLBINDSAMPLERPROC glBindSampler;
extern PFNGLBINDSAMPLERSPROC glBindSamplers;
extern PFNGLBINDTEXTUREPROC glBindTexture;
extern PFNGLBINDTEXTURESPROC glBindTextures;
extern PFNGLBINDTEXTUREUNITPROC glBindTextureUnit;
extern PFNGLBINDTRANSFORMFEEDBACKPROC glBindTransformFeedback;
extern PFNGLBINDVERTEXARRAYPROC glBindVertexArray;
extern PFNGLBINDVERTEXBUFFERPROC glBindVertexBuffer;
extern PFNGLBINDVERTEXBUFFERSPROC glBindVertexBuffers;
extern PFNGLBLENDBARRIERKHRPROC glBlendBarrierKHR;
extern PFNGLBLENDBARRIERNVPROC glBlendBarrierNV;
extern PFNGLBLENDCOLORPROC glBlendColor;
extern PFNGLBLENDEQUATIONIARBPROC glBlendEquationiARB;
extern PFNGLBLENDEQUATIONIPROC glBlendEquationi;
extern PFNGLBLENDEQUATIONPROC glBlendEquation;
extern PFNGLBLENDEQUATIONSEPARATEIARBPROC glBlendEquationSeparateiARB;
extern PFNGLBLENDEQUATIONSEPARATEIPROC glBlendEquationSeparatei;
extern PFNGLBLENDEQUATIONSEPARATEPROC glBlendEquationSeparate;
extern PFNGLBLENDFUNCIARBPROC glBlendFunciARB;
extern PFNGLBLENDFUNCIPROC glBlendFunci;
extern PFNGLBLENDFUNCPROC glBlendFunc;
extern PFNGLBLENDFUNCSEPARATEIARBPROC glBlendFuncSeparateiARB;
extern PFNGLBLENDFUNCSEPARATEIPROC glBlendFuncSeparatei;
extern PFNGLBLENDFUNCSEPARATEPROC glBlendFuncSeparate;
extern PFNGLBLENDPARAMETERINVPROC glBlendParameteriNV;
extern PFNGLBLITFRAMEBUFFERPROC glBlitFramebuffer;
extern PFNGLBLITNAMEDFRAMEBUFFERPROC glBlitNamedFramebuffer;
extern PFNGLBUFFERADDRESSRANGENVPROC glBufferAddressRangeNV;
extern PFNGLBUFFERDATAPROC glBufferData;
extern PFNGLBUFFERPAGECOMMITMENTARBPROC glBufferPageCommitmentARB;
extern PFNGLBUFFERSTORAGEPROC glBufferStorage;
extern PFNGLBUFFERSUBDATAPROC glBufferSubData;
extern PFNGLCALLCOMMANDLISTNVPROC glCallCommandListNV;
extern PFNGLCHECKFRAMEBUFFERSTATUSPROC glCheckFramebufferStatus;
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC glCheckNamedFramebufferStatusEXT;
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glCheckNamedFramebufferStatus;
extern PFNGLCLAMPCOLORPROC glClampColor;
extern PFNGLCLEARBUFFERDATAPROC glClearBufferData;
extern PFNGLCLEARBUFFERFIPROC glClearBufferfi;
extern PFNGLCLEARBUFFERFVPROC glClearBufferfv;
extern PFNGLCLEARBUFFERIVPROC glClearBufferiv;
extern PFNGLCLEARBUFFERSUBDATAPROC glClearBufferSubData;
extern PFNGLCLEARBUFFERUIVPROC glClearBufferuiv;
extern PFNGLCLEARCOLORPROC glClearColor;
extern PFNGLCLEARDEPTHFPROC glClearDepthf;
extern PFNGLCLEARDEPTHPROC glClearDepth;
extern PFNGLCLEARNAMEDBUFFERDATAEXTPROC glClearNamedBufferDataEXT;
extern PFNGLCLEARNAMEDBUFFERDATAPROC glClearNamedBufferData;
extern PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC glClearNamedBufferSubDataEXT;
extern PFNGLCLEARNAMEDBUFFERSUBDATAPROC glClearNamedBufferSubData;
extern PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glClearNamedFramebufferfi;
extern PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glClearNamedFramebufferfv;
extern PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glClearNamedFramebufferiv;
extern PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glClearNamedFramebufferuiv;
extern PFNGLCLEARPROC glClear;
extern PFNGLCLEARSTENCILPROC glClearStencil;
extern PFNGLCLEARTEXIMAGEPROC glClearTexImage;
extern PFNGLCLEARTEXSUBIMAGEPROC glClearTexSubImage;
extern PFNGLCLIENTATTRIBDEFAULTEXTPROC glClientAttribDefaultEXT;
extern PFNGLCLIENTWAITSYNCPROC glClientWaitSync;
extern PFNGLCLIPCONTROLPROC glClipControl;
extern PFNGLCOLORFORMATNVPROC glColorFormatNV;
extern PFNGLCOLORMASKIPROC glColorMaski;
extern PFNGLCOLORMASKPROC glColorMask;
extern PFNGLCOMMANDLISTSEGMENTSNVPROC glCommandListSegmentsNV;
extern PFNGLCOMPILECOMMANDLISTNVPROC glCompileCommandListNV;
extern PFNGLCOMPILESHADERINCLUDEARBPROC glCompileShaderIncludeARB;
extern PFNGLCOMPILESHADERPROC glCompileShader;
extern PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC glCompressedMultiTexImage1DEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC glCompressedMultiTexImage2DEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC glCompressedMultiTexImage3DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC glCompressedMultiTexSubImage1DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC glCompressedMultiTexSubImage2DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC glCompressedMultiTexSubImage3DEXT;
extern PFNGLCOMPRESSEDTEXIMAGE1DPROC glCompressedTexImage1D;
extern PFNGLCOMPRESSEDTEXIMAGE2DPROC glCompressedTexImage2D;
extern PFNGLCOMPRESSEDTEXIMAGE3DPROC glCompressedTexImage3D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glCompressedTexSubImage1D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glCompressedTexSubImage2D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glCompressedTexSubImage3D;
extern PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC glCompressedTextureImage1DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC glCompressedTextureImage2DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC glCompressedTextureImage3DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC glCompressedTextureSubImage1DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glCompressedTextureSubImage1D;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC glCompressedTextureSubImage2DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glCompressedTextureSubImage2D;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC glCompressedTextureSubImage3DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glCompressedTextureSubImage3D;
extern PFNGLCONSERVATIVERASTERPARAMETERFNVPROC glConservativeRasterParameterfNV;
extern PFNGLCONSERVATIVERASTERPARAMETERINVPROC glConservativeRasterParameteriNV;
extern PFNGLCOPYBUFFERSUBDATAPROC glCopyBufferSubData;
extern PFNGLCOPYIMAGESUBDATAPROC glCopyImageSubData;
extern PFNGLCOPYMULTITEXIMAGE1DEXTPROC glCopyMultiTexImage1DEXT;
extern PFNGLCOPYMULTITEXIMAGE2DEXTPROC glCopyMultiTexImage2DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC glCopyMultiTexSubImage1DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC glCopyMultiTexSubImage2DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC glCopyMultiTexSubImage3DEXT;
extern PFNGLCOPYNAMEDBUFFERSUBDATAPROC glCopyNamedBufferSubData;
extern PFNGLCOPYPATHNVPROC glCopyPathNV;
extern PFNGLCOPYTEXIMAGE1DPROC glCopyTexImage1D;
extern PFNGLCOPYTEXIMAGE2DPROC glCopyTexImage2D;
extern PFNGLCOPYTEXSUBIMAGE1DPROC glCopyTexSubImage1D;
extern PFNGLCOPYTEXSUBIMAGE2DPROC glCopyTexSubImage2D;
extern PFNGLCOPYTEXSUBIMAGE3DPROC glCopyTexSubImage3D;
extern PFNGLCOPYTEXTUREIMAGE1DEXTPROC glCopyTextureImage1DEXT;
extern PFNGLCOPYTEXTUREIMAGE2DEXTPROC glCopyTextureImage2DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC glCopyTextureSubImage1DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE1DPROC glCopyTextureSubImage1D;
extern PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC glCopyTextureSubImage2DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE2DPROC glCopyTextureSubImage2D;
extern PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC glCopyTextureSubImage3DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE3DPROC glCopyTextureSubImage3D;
extern PFNGLCOVERAGEMODULATIONNVPROC glCoverageModulationNV;
extern PFNGLCOVERAGEMODULATIONTABLENVPROC glCoverageModulationTableNV;
extern PFNGLCOVERFILLPATHINSTANCEDNVPROC glCoverFillPathInstancedNV;
extern PFNGLCOVERFILLPATHNVPROC glCoverFillPathNV;
extern PFNGLCOVERSTROKEPATHINSTANCEDNVPROC glCoverStrokePathInstancedNV;
extern PFNGLCOVERSTROKEPATHNVPROC glCoverStrokePathNV;
extern PFNGLCREATEBUFFERSPROC glCreateBuffers;
extern PFNGLCREATECOMMANDLISTSNVPROC glCreateCommandListsNV;
extern PFNGLCREATEFRAMEBUFFERSPROC glCreateFramebuffers;
extern PFNGLCREATEPERFQUERYINTELPROC glCreatePerfQueryINTEL;
extern PFNGLCREATEPROGRAMPIPELINESPROC glCreateProgramPipelines;
extern PFNGLCREATEPROGRAMPROC glCreateProgram;
extern PFNGLCREATEQUERIESPROC glCreateQueries;
extern PFNGLCREATERENDERBUFFERSPROC glCreateRenderbuffers;
extern PFNGLCREATESAMPLERSPROC glCreateSamplers;
extern PFNGLCREATESHADERPROC glCreateShader;
extern PFNGLCREATESHADERPROGRAMEXTPROC glCreateShaderProgramEXT;
extern PFNGLCREATESHADERPROGRAMVPROC glCreateShaderProgramv;
extern PFNGLCREATESTATESNVPROC glCreateStatesNV;
extern PFNGLCREATESYNCFROMCLEVENTARBPROC glCreateSyncFromCLeventARB;
extern PFNGLCREATETEXTURESPROC glCreateTextures;
extern PFNGLCREATETRANSFORMFEEDBACKSPROC glCreateTransformFeedbacks;
extern PFNGLCREATEVERTEXARRAYSPROC glCreateVertexArrays;
extern PFNGLCULLFACEPROC glCullFace;
extern PFNGLDEBUGMESSAGECALLBACKARBPROC glDebugMessageCallbackARB;
extern PFNGLDEBUGMESSAGECALLBACKPROC glDebugMessageCallback;
extern PFNGLDEBUGMESSAGECONTROLARBPROC glDebugMessageControlARB;
extern PFNGLDEBUGMESSAGECONTROLPROC glDebugMessageControl;
extern PFNGLDEBUGMESSAGEINSERTARBPROC glDebugMessageInsertARB;
extern PFNGLDEBUGMESSAGEINSERTPROC glDebugMessageInsert;
extern PFNGLDELETEBUFFERSPROC glDeleteBuffers;
extern PFNGLDELETECOMMANDLISTSNVPROC glDeleteCommandListsNV;
extern PFNGLDELETEFRAMEBUFFERSPROC glDeleteFramebuffers;
extern PFNGLDELETENAMEDSTRINGARBPROC glDeleteNamedStringARB;
extern PFNGLDELETEPATHSNVPROC glDeletePathsNV;
extern PFNGLDELETEPERFMONITORSAMDPROC glDeletePerfMonitorsAMD;
extern PFNGLDELETEPERFQUERYINTELPROC glDeletePerfQueryINTEL;
extern PFNGLDELETEPROGRAMPIPELINESPROC glDeleteProgramPipelines;
extern PFNGLDELETEPROGRAMPROC glDeleteProgram;
extern PFNGLDELETEQUERIESPROC glDeleteQueries;
extern PFNGLDELETERENDERBUFFERSPROC glDeleteRenderbuffers;
extern PFNGLDELETESAMPLERSPROC glDeleteSamplers;
extern PFNGLDELETESHADERPROC glDeleteShader;
extern PFNGLDELETESTATESNVPROC glDeleteStatesNV;
extern PFNGLDELETESYNCPROC glDeleteSync;
extern PFNGLDELETETEXTURESPROC glDeleteTextures;
extern PFNGLDELETETRANSFORMFEEDBACKSPROC glDeleteTransformFeedbacks;
extern PFNGLDELETEVERTEXARRAYSPROC glDeleteVertexArrays;
extern PFNGLDEPTHFUNCPROC glDepthFunc;
extern PFNGLDEPTHMASKPROC glDepthMask;
extern PFNGLDEPTHRANGEARRAYVPROC glDepthRangeArrayv;
extern PFNGLDEPTHRANGEFPROC glDepthRangef;
extern PFNGLDEPTHRANGEINDEXEDPROC glDepthRangeIndexed;
extern PFNGLDEPTHRANGEPROC glDepthRange;
extern PFNGLDETACHSHADERPROC glDetachShader;
extern PFNGLDISABLECLIENTSTATEIEXTPROC glDisableClientStateiEXT;
extern PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC glDisableClientStateIndexedEXT;
extern PFNGLDISABLEINDEXEDEXTPROC glDisableIndexedEXT;
extern PFNGLDISABLEIPROC glDisablei;
extern PFNGLDISABLEPROC glDisable;
extern PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC glDisableVertexArrayAttribEXT;
extern PFNGLDISABLEVERTEXARRAYATTRIBPROC glDisableVertexArrayAttrib;
extern PFNGLDISABLEVERTEXARRAYEXTPROC glDisableVertexArrayEXT;
extern PFNGLDISABLEVERTEXATTRIBARRAYPROC glDisableVertexAttribArray;
extern PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC glDispatchComputeGroupSizeARB;
extern PFNGLDISPATCHCOMPUTEINDIRECTPROC glDispatchComputeIndirect;
extern PFNGLDISPATCHCOMPUTEPROC glDispatchCompute;
extern PFNGLDRAWARRAYSINDIRECTPROC glDrawArraysIndirect;
extern PFNGLDRAWARRAYSINSTANCEDARBPROC glDrawArraysInstancedARB;
extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glDrawArraysInstancedBaseInstance;
extern PFNGLDRAWARRAYSINSTANCEDEXTPROC glDrawArraysInstancedEXT;
extern PFNGLDRAWARRAYSINSTANCEDPROC glDrawArraysInstanced;
extern PFNGLDRAWARRAYSPROC glDrawArrays;
extern PFNGLDRAWBUFFERPROC glDrawBuffer;
extern PFNGLDRAWBUFFERSPROC glDrawBuffers;
extern PFNGLDRAWCOMMANDSADDRESSNVPROC glDrawCommandsAddressNV;
extern PFNGLDRAWCOMMANDSNVPROC glDrawCommandsNV;
extern PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC glDrawCommandsStatesAddressNV;
extern PFNGLDRAWCOMMANDSSTATESNVPROC glDrawCommandsStatesNV;
extern PFNGLDRAWELEMENTSBASEVERTEXPROC glDrawElementsBaseVertex;
extern PFNGLDRAWELEMENTSINDIRECTPROC glDrawElementsIndirect;
extern PFNGLDRAWELEMENTSINSTANCEDARBPROC glDrawElementsInstancedARB;
extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glDrawElementsInstancedBaseInstance;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glDrawElementsInstancedBaseVertexBaseInstance;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glDrawElementsInstancedBaseVertex;
extern PFNGLDRAWELEMENTSINSTANCEDEXTPROC glDrawElementsInstancedEXT;
extern PFNGLDRAWELEMENTSINSTANCEDPROC glDrawElementsInstanced;
extern PFNGLDRAWELEMENTSPROC glDrawElements;
extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glDrawRangeElementsBaseVertex;
extern PFNGLDRAWRANGEELEMENTSPROC glDrawRangeElements;
extern PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glDrawTransformFeedbackInstanced;
extern PFNGLDRAWTRANSFORMFEEDBACKPROC glDrawTransformFeedback;
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glDrawTransformFeedbackStreamInstanced;
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glDrawTransformFeedbackStream;
extern PFNGLDRAWVKIMAGENVPROC glDrawVkImageNV;
extern PFNGLEDGEFLAGFORMATNVPROC glEdgeFlagFormatNV;
extern PFNGLENABLECLIENTSTATEIEXTPROC glEnableClientStateiEXT;
extern PFNGLENABLECLIENTSTATEINDEXEDEXTPROC glEnableClientStateIndexedEXT;
extern PFNGLENABLEINDEXEDEXTPROC glEnableIndexedEXT;
extern PFNGLENABLEIPROC glEnablei;
extern PFNGLENABLEPROC glEnable;
extern PFNGLENABLEVERTEXARRAYATTRIBEXTPROC glEnableVertexArrayAttribEXT;
extern PFNGLENABLEVERTEXARRAYATTRIBPROC glEnableVertexArrayAttrib;
extern PFNGLENABLEVERTEXARRAYEXTPROC glEnableVertexArrayEXT;
extern PFNGLENABLEVERTEXATTRIBARRAYPROC glEnableVertexAttribArray;
extern PFNGLENDCONDITIONALRENDERNVPROC glEndConditionalRenderNV;
extern PFNGLENDCONDITIONALRENDERPROC glEndConditionalRender;
extern PFNGLENDPERFMONITORAMDPROC glEndPerfMonitorAMD;
extern PFNGLENDPERFQUERYINTELPROC glEndPerfQueryINTEL;
extern PFNGLENDQUERYINDEXEDPROC glEndQueryIndexed;
extern PFNGLENDQUERYPROC glEndQuery;
extern PFNGLENDTRANSFORMFEEDBACKPROC glEndTransformFeedback;
extern PFNGLEVALUATEDEPTHVALUESARBPROC glEvaluateDepthValuesARB;
extern PFNGLFENCESYNCPROC glFenceSync;
extern PFNGLFINISHPROC glFinish;
extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC glFlushMappedBufferRange;
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC glFlushMappedNamedBufferRangeEXT;
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glFlushMappedNamedBufferRange;
extern PFNGLFLUSHPROC glFlush;
extern PFNGLFOGCOORDFORMATNVPROC glFogCoordFormatNV;
extern PFNGLFRAGMENTCOVERAGECOLORNVPROC glFragmentCoverageColorNV;
extern PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC glFramebufferDrawBufferEXT;
extern PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC glFramebufferDrawBuffersEXT;
extern PFNGLFRAMEBUFFERPARAMETERIPROC glFramebufferParameteri;
extern PFNGLFRAMEBUFFERREADBUFFEREXTPROC glFramebufferReadBufferEXT;
extern PFNGLFRAMEBUFFERRENDERBUFFERPROC glFramebufferRenderbuffer;
extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glFramebufferSampleLocationsfvARB;
extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glFramebufferSampleLocationsfvNV;
extern PFNGLFRAMEBUFFERTEXTURE1DPROC glFramebufferTexture1D;
extern PFNGLFRAMEBUFFERTEXTURE2DPROC glFramebufferTexture2D;
extern PFNGLFRAMEBUFFERTEXTURE3DPROC glFramebufferTexture3D;
extern PFNGLFRAMEBUFFERTEXTUREARBPROC glFramebufferTextureARB;
extern PFNGLFRAMEBUFFERTEXTUREFACEARBPROC glFramebufferTextureFaceARB;
extern PFNGLFRAMEBUFFERTEXTURELAYERARBPROC glFramebufferTextureLayerARB;
extern PFNGLFRAMEBUFFERTEXTURELAYERPROC glFramebufferTextureLayer;
extern PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC glFramebufferTextureMultiviewOVR;
extern PFNGLFRAMEBUFFERTEXTUREPROC glFramebufferTexture;
extern PFNGLFRONTFACEPROC glFrontFace;
extern PFNGLGENBUFFERSPROC glGenBuffers;
extern PFNGLGENERATEMIPMAPPROC glGenerateMipmap;
extern PFNGLGENERATEMULTITEXMIPMAPEXTPROC glGenerateMultiTexMipmapEXT;
extern PFNGLGENERATETEXTUREMIPMAPEXTPROC glGenerateTextureMipmapEXT;
extern PFNGLGENERATETEXTUREMIPMAPPROC glGenerateTextureMipmap;
extern PFNGLGENFRAMEBUFFERSPROC glGenFramebuffers;
extern PFNGLGENPATHSNVPROC glGenPathsNV;
extern PFNGLGENPERFMONITORSAMDPROC glGenPerfMonitorsAMD;
extern PFNGLGENPROGRAMPIPELINESPROC glGenProgramPipelines;
extern PFNGLGENQUERIESPROC glGenQueries;
extern PFNGLGENRENDERBUFFERSPROC glGenRenderbuffers;
extern PFNGLGENSAMPLERSPROC glGenSamplers;
extern PFNGLGENTEXTURESPROC glGenTextures;
extern PFNGLGENTRANSFORMFEEDBACKSPROC glGenTransformFeedbacks;
extern PFNGLGENVERTEXARRAYSPROC glGenVertexArrays;
extern PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glGetActiveAtomicCounterBufferiv;
extern PFNGLGETACTIVEATTRIBPROC glGetActiveAttrib;
extern PFNGLGETACTIVESUBROUTINENAMEPROC glGetActiveSubroutineName;
extern PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glGetActiveSubroutineUniformiv;
extern PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glGetActiveSubroutineUniformName;
extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC glGetActiveUniformBlockiv;
extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glGetActiveUniformBlockName;
extern PFNGLGETACTIVEUNIFORMNAMEPROC glGetActiveUniformName;
extern PFNGLGETACTIVEUNIFORMPROC glGetActiveUniform;
extern PFNGLGETACTIVEUNIFORMSIVPROC glGetActiveUniformsiv;
extern PFNGLGETATTACHEDSHADERSPROC glGetAttachedShaders;
extern PFNGLGETATTRIBLOCATIONPROC glGetAttribLocation;
extern PFNGLGETBOOLEANINDEXEDVEXTPROC glGetBooleanIndexedvEXT;
extern PFNGLGETBOOLEANI_VPROC glGetBooleani_v;
extern PFNGLGETBOOLEANVPROC glGetBooleanv;
extern PFNGLGETBUFFERPARAMETERI64VPROC glGetBufferParameteri64v;
extern PFNGLGETBUFFERPARAMETERIVPROC glGetBufferParameteriv;
extern PFNGLGETBUFFERPARAMETERUI64VNVPROC glGetBufferParameterui64vNV;
extern PFNGLGETBUFFERPOINTERVPROC glGetBufferPointerv;
extern PFNGLGETBUFFERSUBDATAPROC glGetBufferSubData;
extern PFNGLGETCOMMANDHEADERNVPROC glGetCommandHeaderNV;
extern PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC glGetCompressedMultiTexImageEXT;
extern PFNGLGETCOMPRESSEDTEXIMAGEPROC glGetCompressedTexImage;
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC glGetCompressedTextureImageEXT;
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glGetCompressedTextureImage;
extern PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glGetCompressedTextureSubImage;
extern PFNGLGETCOVERAGEMODULATIONTABLENVPROC glGetCoverageModulationTableNV;
extern PFNGLGETDEBUGMESSAGELOGARBPROC glGetDebugMessageLogARB;
extern PFNGLGETDEBUGMESSAGELOGPROC glGetDebugMessageLog;
extern PFNGLGETDOUBLEINDEXEDVEXTPROC glGetDoubleIndexedvEXT;
extern PFNGLGETDOUBLEI_VEXTPROC glGetDoublei_vEXT;
extern PFNGLGETDOUBLEI_VPROC glGetDoublei_v;
extern PFNGLGETDOUBLEVPROC glGetDoublev;
extern PFNGLGETERRORPROC glGetError;
extern PFNGLGETFIRSTPERFQUERYIDINTELPROC glGetFirstPerfQueryIdINTEL;
extern PFNGLGETFLOATINDEXEDVEXTPROC glGetFloatIndexedvEXT;
extern PFNGLGETFLOATI_VEXTPROC glGetFloati_vEXT;
extern PFNGLGETFLOATI_VPROC glGetFloati_v;
extern PFNGLGETFLOATVPROC glGetFloatv;
extern PFNGLGETFRAGDATAINDEXPROC glGetFragDataIndex;
extern PFNGLGETFRAGDATALOCATIONPROC glGetFragDataLocation;
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glGetFramebufferAttachmentParameteriv;
extern PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC glGetFramebufferParameterivEXT;
extern PFNGLGETFRAMEBUFFERPARAMETERIVPROC glGetFramebufferParameteriv;
extern PFNGLGETGRAPHICSRESETSTATUSARBPROC glGetGraphicsResetStatusARB;
extern PFNGLGETGRAPHICSRESETSTATUSPROC glGetGraphicsResetStatus;
extern PFNGLGETIMAGEHANDLEARBPROC glGetImageHandleARB;
extern PFNGLGETIMAGEHANDLENVPROC glGetImageHandleNV;
extern PFNGLGETINTEGER64I_VPROC glGetInteger64i_v;
extern PFNGLGETINTEGER64VPROC glGetInteger64v;
extern PFNGLGETINTEGERINDEXEDVEXTPROC glGetIntegerIndexedvEXT;
extern PFNGLGETINTEGERI_VPROC glGetIntegeri_v;
extern PFNGLGETINTEGERUI64I_VNVPROC glGetIntegerui64i_vNV;
extern PFNGLGETINTEGERUI64VNVPROC glGetIntegerui64vNV;
extern PFNGLGETINTEGERVPROC glGetIntegerv;
extern PFNGLGETINTERNALFORMATI64VPROC glGetInternalformati64v;
extern PFNGLGETINTERNALFORMATIVPROC glGetInternalformativ;
extern PFNGLGETINTERNALFORMATSAMPLEIVNVPROC glGetInternalformatSampleivNV;
extern PFNGLGETMULTISAMPLEFVPROC glGetMultisamplefv;
extern PFNGLGETMULTITEXENVFVEXTPROC glGetMultiTexEnvfvEXT;
extern PFNGLGETMULTITEXENVIVEXTPROC glGetMultiTexEnvivEXT;
extern PFNGLGETMULTITEXGENDVEXTPROC glGetMultiTexGendvEXT;
extern PFNGLGETMULTITEXGENFVEXTPROC glGetMultiTexGenfvEXT;
extern PFNGLGETMULTITEXGENIVEXTPROC glGetMultiTexGenivEXT;
extern PFNGLGETMULTITEXIMAGEEXTPROC glGetMultiTexImageEXT;
extern PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC glGetMultiTexLevelParameterfvEXT;
extern PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC glGetMultiTexLevelParameterivEXT;
extern PFNGLGETMULTITEXPARAMETERFVEXTPROC glGetMultiTexParameterfvEXT;
extern PFNGLGETMULTITEXPARAMETERIIVEXTPROC glGetMultiTexParameterIivEXT;
extern PFNGLGETMULTITEXPARAMETERIUIVEXTPROC glGetMultiTexParameterIuivEXT;
extern PFNGLGETMULTITEXPARAMETERIVEXTPROC glGetMultiTexParameterivEXT;
extern PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glGetNamedBufferParameteri64v;
extern PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC glGetNamedBufferParameterivEXT;
extern PFNGLGETNAMEDBUFFERPARAMETERIVPROC glGetNamedBufferParameteriv;
extern PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC glGetNamedBufferParameterui64vNV;
extern PFNGLGETNAMEDBUFFERPOINTERVEXTPROC glGetNamedBufferPointervEXT;
extern PFNGLGETNAMEDBUFFERPOINTERVPROC glGetNamedBufferPointerv;
extern PFNGLGETNAMEDBUFFERSUBDATAEXTPROC glGetNamedBufferSubDataEXT;
extern PFNGLGETNAMEDBUFFERSUBDATAPROC glGetNamedBufferSubData;
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glGetNamedFramebufferAttachmentParameterivEXT;
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glGetNamedFramebufferAttachmentParameteriv;
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC glGetNamedFramebufferParameterivEXT;
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glGetNamedFramebufferParameteriv;
extern PFNGLGETNAMEDPROGRAMIVEXTPROC glGetNamedProgramivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC glGetNamedProgramLocalParameterdvEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC glGetNamedProgramLocalParameterfvEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC glGetNamedProgramLocalParameterIivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC glGetNamedProgramLocalParameterIuivEXT;
extern PFNGLGETNAMEDPROGRAMSTRINGEXTPROC glGetNamedProgramStringEXT;
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC glGetNamedRenderbufferParameterivEXT;
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glGetNamedRenderbufferParameteriv;
extern PFNGLGETNAMEDSTRINGARBPROC glGetNamedStringARB;
extern PFNGLGETNAMEDSTRINGIVARBPROC glGetNamedStringivARB;
extern PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glGetnCompressedTexImageARB;
extern PFNGLGETNCOMPRESSEDTEXIMAGEPROC glGetnCompressedTexImage;
extern PFNGLGETNEXTPERFQUERYIDINTELPROC glGetNextPerfQueryIdINTEL;
extern PFNGLGETNTEXIMAGEARBPROC glGetnTexImageARB;
extern PFNGLGETNTEXIMAGEPROC glGetnTexImage;
extern PFNGLGETNUNIFORMDVARBPROC glGetnUniformdvARB;
extern PFNGLGETNUNIFORMDVPROC glGetnUniformdv;
extern PFNGLGETNUNIFORMFVARBPROC glGetnUniformfvARB;
extern PFNGLGETNUNIFORMFVPROC glGetnUniformfv;
extern PFNGLGETNUNIFORMI64VARBPROC glGetnUniformi64vARB;
extern PFNGLGETNUNIFORMIVARBPROC glGetnUniformivARB;
extern PFNGLGETNUNIFORMIVPROC glGetnUniformiv;
extern PFNGLGETNUNIFORMUI64VARBPROC glGetnUniformui64vARB;
extern PFNGLGETNUNIFORMUIVARBPROC glGetnUniformuivARB;
extern PFNGLGETNUNIFORMUIVPROC glGetnUniformuiv;
extern PFNGLGETOBJECTLABELEXTPROC glGetObjectLabelEXT;
extern PFNGLGETOBJECTLABELPROC glGetObjectLabel;
extern PFNGLGETOBJECTPTRLABELPROC glGetObjectPtrLabel;
extern PFNGLGETPATHCOMMANDSNVPROC glGetPathCommandsNV;
extern PFNGLGETPATHCOORDSNVPROC glGetPathCoordsNV;
extern PFNGLGETPATHDASHARRAYNVPROC glGetPathDashArrayNV;
extern PFNGLGETPATHLENGTHNVPROC glGetPathLengthNV;
extern PFNGLGETPATHMETRICRANGENVPROC glGetPathMetricRangeNV;
extern PFNGLGETPATHMETRICSNVPROC glGetPathMetricsNV;
extern PFNGLGETPATHPARAMETERFVNVPROC glGetPathParameterfvNV;
extern PFNGLGETPATHPARAMETERIVNVPROC glGetPathParameterivNV;
extern PFNGLGETPATHSPACINGNVPROC glGetPathSpacingNV;
extern PFNGLGETPERFCOUNTERINFOINTELPROC glGetPerfCounterInfoINTEL;
extern PFNGLGETPERFMONITORCOUNTERDATAAMDPROC glGetPerfMonitorCounterDataAMD;
extern PFNGLGETPERFMONITORCOUNTERINFOAMDPROC glGetPerfMonitorCounterInfoAMD;
extern PFNGLGETPERFMONITORCOUNTERSAMDPROC glGetPerfMonitorCountersAMD;
extern PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC glGetPerfMonitorCounterStringAMD;
extern PFNGLGETPERFMONITORGROUPSAMDPROC glGetPerfMonitorGroupsAMD;
extern PFNGLGETPERFMONITORGROUPSTRINGAMDPROC glGetPerfMonitorGroupStringAMD;
extern PFNGLGETPERFQUERYDATAINTELPROC glGetPerfQueryDataINTEL;
extern PFNGLGETPERFQUERYIDBYNAMEINTELPROC glGetPerfQueryIdByNameINTEL;
extern PFNGLGETPERFQUERYINFOINTELPROC glGetPerfQueryInfoINTEL;
extern PFNGLGETPOINTERINDEXEDVEXTPROC glGetPointerIndexedvEXT;
extern PFNGLGETPOINTERI_VEXTPROC glGetPointeri_vEXT;
extern PFNGLGETPOINTERVPROC glGetPointerv;
extern PFNGLGETPROGRAMBINARYPROC glGetProgramBinary;
extern PFNGLGETPROGRAMINFOLOGPROC glGetProgramInfoLog;
extern PFNGLGETPROGRAMINTERFACEIVPROC glGetProgramInterfaceiv;
extern PFNGLGETPROGRAMIVPROC glGetProgramiv;
extern PFNGLGETPROGRAMPIPELINEINFOLOGPROC glGetProgramPipelineInfoLog;
extern PFNGLGETPROGRAMPIPELINEIVPROC glGetProgramPipelineiv;
extern PFNGLGETPROGRAMRESOURCEFVNVPROC glGetProgramResourcefvNV;
extern PFNGLGETPROGRAMRESOURCEINDEXPROC glGetProgramResourceIndex;
extern PFNGLGETPROGRAMRESOURCEIVPROC glGetProgramResourceiv;
extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glGetProgramResourceLocationIndex;
extern PFNGLGETPROGRAMRESOURCELOCATIONPROC glGetProgramResourceLocation;
extern PFNGLGETPROGRAMRESOURCENAMEPROC glGetProgramResourceName;
extern PFNGLGETPROGRAMSTAGEIVPROC glGetProgramStageiv;
extern PFNGLGETQUERYBUFFEROBJECTI64VPROC glGetQueryBufferObjecti64v;
extern PFNGLGETQUERYBUFFEROBJECTIVPROC glGetQueryBufferObjectiv;
extern PFNGLGETQUERYBUFFEROBJECTUI64VPROC glGetQueryBufferObjectui64v;
extern PFNGLGETQUERYBUFFEROBJECTUIVPROC glGetQueryBufferObjectuiv;
extern PFNGLGETQUERYINDEXEDIVPROC glGetQueryIndexediv;
extern PFNGLGETQUERYIVPROC glGetQueryiv;
extern PFNGLGETQUERYOBJECTI64VPROC glGetQueryObjecti64v;
extern PFNGLGETQUERYOBJECTIVPROC glGetQueryObjectiv;
extern PFNGLGETQUERYOBJECTUI64VPROC glGetQueryObjectui64v;
extern PFNGLGETQUERYOBJECTUIVPROC glGetQueryObjectuiv;
extern PFNGLGETRENDERBUFFERPARAMETERIVPROC glGetRenderbufferParameteriv;
extern PFNGLGETSAMPLERPARAMETERFVPROC glGetSamplerParameterfv;
extern PFNGLGETSAMPLERPARAMETERIIVPROC glGetSamplerParameterIiv;
extern PFNGLGETSAMPLERPARAMETERIUIVPROC glGetSamplerParameterIuiv;
extern PFNGLGETSAMPLERPARAMETERIVPROC glGetSamplerParameteriv;
extern PFNGLGETSHADERINFOLOGPROC glGetShaderInfoLog;
extern PFNGLGETSHADERIVPROC glGetShaderiv;
extern PFNGLGETSHADERPRECISIONFORMATPROC glGetShaderPrecisionFormat;
extern PFNGLGETSHADERSOURCEPROC glGetShaderSource;
extern PFNGLGETSTAGEINDEXNVPROC glGetStageIndexNV;
extern PFNGLGETSTRINGIPROC glGetStringi;
extern PFNGLGETSTRINGPROC glGetString;
extern PFNGLGETSUBROUTINEINDEXPROC glGetSubroutineIndex;
extern PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glGetSubroutineUniformLocation;
extern PFNGLGETSYNCIVPROC glGetSynciv;
extern PFNGLGETTEXIMAGEPROC glGetTexImage;
extern PFNGLGETTEXLEVELPARAMETERFVPROC glGetTexLevelParameterfv;
extern PFNGLGETTEXLEVELPARAMETERIVPROC glGetTexLevelParameteriv;
extern PFNGLGETTEXPARAMETERFVPROC glGetTexParameterfv;
extern PFNGLGETTEXPARAMETERIIVPROC glGetTexParameterIiv;
extern PFNGLGETTEXPARAMETERIUIVPROC glGetTexParameterIuiv;
extern PFNGLGETTEXPARAMETERIVPROC glGetTexParameteriv;
extern PFNGLGETTEXTUREHANDLEARBPROC glGetTextureHandleARB;
extern PFNGLGETTEXTUREHANDLENVPROC glGetTextureHandleNV;
extern PFNGLGETTEXTUREIMAGEEXTPROC glGetTextureImageEXT;
extern PFNGLGETTEXTUREIMAGEPROC glGetTextureImage;
extern PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC glGetTextureLevelParameterfvEXT;
extern PFNGLGETTEXTURELEVELPARAMETERFVPROC glGetTextureLevelParameterfv;
extern PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC glGetTextureLevelParameterivEXT;
extern PFNGLGETTEXTURELEVELPARAMETERIVPROC glGetTextureLevelParameteriv;
extern PFNGLGETTEXTUREPARAMETERFVEXTPROC glGetTextureParameterfvEXT;
extern PFNGLGETTEXTUREPARAMETERFVPROC glGetTextureParameterfv;
extern PFNGLGETTEXTUREPARAMETERIIVEXTPROC glGetTextureParameterIivEXT;
extern PFNGLGETTEXTUREPARAMETERIIVPROC glGetTextureParameterIiv;
extern PFNGLGETTEXTUREPARAMETERIUIVEXTPROC glGetTextureParameterIuivEXT;
extern PFNGLGETTEXTUREPARAMETERIUIVPROC glGetTextureParameterIuiv;
extern PFNGLGETTEXTUREPARAMETERIVEXTPROC glGetTextureParameterivEXT;
extern PFNGLGETTEXTUREPARAMETERIVPROC glGetTextureParameteriv;
extern PFNGLGETTEXTURESAMPLERHANDLEARBPROC glGetTextureSamplerHandleARB;
extern PFNGLGETTEXTURESAMPLERHANDLENVPROC glGetTextureSamplerHandleNV;
extern PFNGLGETTEXTURESUBIMAGEPROC glGetTextureSubImage;
extern PFNGLGETTRANSFORMFEEDBACKI64_VPROC glGetTransformFeedbacki64_v;
extern PFNGLGETTRANSFORMFEEDBACKIVPROC glGetTransformFeedbackiv;
extern PFNGLGETTRANSFORMFEEDBACKI_VPROC glGetTransformFeedbacki_v;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glGetTransformFeedbackVarying;
extern PFNGLGETUNIFORMBLOCKINDEXPROC glGetUniformBlockIndex;
extern PFNGLGETUNIFORMDVPROC glGetUniformdv;
extern PFNGLGETUNIFORMFVPROC glGetUniformfv;
extern PFNGLGETUNIFORMI64VARBPROC glGetUniformi64vARB;
extern PFNGLGETUNIFORMI64VNVPROC glGetUniformi64vNV;
extern PFNGLGETUNIFORMINDICESPROC glGetUniformIndices;
extern PFNGLGETUNIFORMIVPROC glGetUniformiv;
extern PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation;
extern PFNGLGETUNIFORMSUBROUTINEUIVPROC glGetUniformSubroutineuiv;
extern PFNGLGETUNIFORMUI64VARBPROC glGetUniformui64vARB;
extern PFNGLGETUNIFORMUI64VNVPROC glGetUniformui64vNV;
extern PFNGLGETUNIFORMUIVPROC glGetUniformuiv;
extern PFNGLGETVERTEXARRAYINDEXED64IVPROC glGetVertexArrayIndexed64iv;
extern PFNGLGETVERTEXARRAYINDEXEDIVPROC glGetVertexArrayIndexediv;
extern PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC glGetVertexArrayIntegeri_vEXT;
extern PFNGLGETVERTEXARRAYINTEGERVEXTPROC glGetVertexArrayIntegervEXT;
extern PFNGLGETVERTEXARRAYIVPROC glGetVertexArrayiv;
extern PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC glGetVertexArrayPointeri_vEXT;
extern PFNGLGETVERTEXARRAYPOINTERVEXTPROC glGetVertexArrayPointervEXT;
extern PFNGLGETVERTEXATTRIBDVPROC glGetVertexAttribdv;
extern PFNGLGETVERTEXATTRIBFVPROC glGetVertexAttribfv;
extern PFNGLGETVERTEXATTRIBIIVPROC glGetVertexAttribIiv;
extern PFNGLGETVERTEXATTRIBIUIVPROC glGetVertexAttribIuiv;
extern PFNGLGETVERTEXATTRIBIVPROC glGetVertexAttribiv;
extern PFNGLGETVERTEXATTRIBLDVPROC glGetVertexAttribLdv;
extern PFNGLGETVERTEXATTRIBLI64VNVPROC glGetVertexAttribLi64vNV;
extern PFNGLGETVERTEXATTRIBLUI64VARBPROC glGetVertexAttribLui64vARB;
extern PFNGLGETVERTEXATTRIBLUI64VNVPROC glGetVertexAttribLui64vNV;
extern PFNGLGETVERTEXATTRIBPOINTERVPROC glGetVertexAttribPointerv;
extern PFNGLGETVKPROCADDRNVPROC glGetVkProcAddrNV;
extern PFNGLHINTPROC glHint;
extern PFNGLINDEXFORMATNVPROC glIndexFormatNV;
extern PFNGLINSERTEVENTMARKEREXTPROC glInsertEventMarkerEXT;
extern PFNGLINTERPOLATEPATHSNVPROC glInterpolatePathsNV;
extern PFNGLINVALIDATEBUFFERDATAPROC glInvalidateBufferData;
extern PFNGLINVALIDATEBUFFERSUBDATAPROC glInvalidateBufferSubData;
extern PFNGLINVALIDATEFRAMEBUFFERPROC glInvalidateFramebuffer;
extern PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glInvalidateNamedFramebufferData;
extern PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glInvalidateNamedFramebufferSubData;
extern PFNGLINVALIDATESUBFRAMEBUFFERPROC glInvalidateSubFramebuffer;
extern PFNGLINVALIDATETEXIMAGEPROC glInvalidateTexImage;
extern PFNGLINVALIDATETEXSUBIMAGEPROC glInvalidateTexSubImage;
extern PFNGLISBUFFERPROC glIsBuffer;
extern PFNGLISBUFFERRESIDENTNVPROC glIsBufferResidentNV;
extern PFNGLISCOMMANDLISTNVPROC glIsCommandListNV;
extern PFNGLISENABLEDINDEXEDEXTPROC glIsEnabledIndexedEXT;
extern PFNGLISENABLEDIPROC glIsEnabledi;
extern PFNGLISENABLEDPROC glIsEnabled;
extern PFNGLISFRAMEBUFFERPROC glIsFramebuffer;
extern PFNGLISIMAGEHANDLERESIDENTARBPROC glIsImageHandleResidentARB;
extern PFNGLISIMAGEHANDLERESIDENTNVPROC glIsImageHandleResidentNV;
extern PFNGLISNAMEDBUFFERRESIDENTNVPROC glIsNamedBufferResidentNV;
extern PFNGLISNAMEDSTRINGARBPROC glIsNamedStringARB;
extern PFNGLISPATHNVPROC glIsPathNV;
extern PFNGLISPOINTINFILLPATHNVPROC glIsPointInFillPathNV;
extern PFNGLISPOINTINSTROKEPATHNVPROC glIsPointInStrokePathNV;
extern PFNGLISPROGRAMPIPELINEPROC glIsProgramPipeline;
extern PFNGLISPROGRAMPROC glIsProgram;
extern PFNGLISQUERYPROC glIsQuery;
extern PFNGLISRENDERBUFFERPROC glIsRenderbuffer;
extern PFNGLISSAMPLERPROC glIsSampler;
extern PFNGLISSHADERPROC glIsShader;
extern PFNGLISSTATENVPROC glIsStateNV;
extern PFNGLISSYNCPROC glIsSync;
extern PFNGLISTEXTUREHANDLERESIDENTARBPROC glIsTextureHandleResidentARB;
extern PFNGLISTEXTUREHANDLERESIDENTNVPROC glIsTextureHandleResidentNV;
extern PFNGLISTEXTUREPROC glIsTexture;
extern PFNGLISTRANSFORMFEEDBACKPROC glIsTransformFeedback;
extern PFNGLISVERTEXARRAYPROC glIsVertexArray;
extern PFNGLLABELOBJECTEXTPROC glLabelObjectEXT;
extern PFNGLLINEWIDTHPROC glLineWidth;
extern PFNGLLINKPROGRAMPROC glLinkProgram;
extern PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC glListDrawCommandsStatesClientNV;
extern PFNGLLOGICOPPROC glLogicOp;
extern PFNGLMAKEBUFFERNONRESIDENTNVPROC glMakeBufferNonResidentNV;
extern PFNGLMAKEBUFFERRESIDENTNVPROC glMakeBufferResidentNV;
extern PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC glMakeImageHandleNonResidentARB;
extern PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC glMakeImageHandleNonResidentNV;
extern PFNGLMAKEIMAGEHANDLERESIDENTARBPROC glMakeImageHandleResidentARB;
extern PFNGLMAKEIMAGEHANDLERESIDENTNVPROC glMakeImageHandleResidentNV;
extern PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC glMakeNamedBufferNonResidentNV;
extern PFNGLMAKENAMEDBUFFERRESIDENTNVPROC glMakeNamedBufferResidentNV;
extern PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC glMakeTextureHandleNonResidentARB;
extern PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC glMakeTextureHandleNonResidentNV;
extern PFNGLMAKETEXTUREHANDLERESIDENTARBPROC glMakeTextureHandleResidentARB;
extern PFNGLMAKETEXTUREHANDLERESIDENTNVPROC glMakeTextureHandleResidentNV;
extern PFNGLMAPBUFFERPROC glMapBuffer;
extern PFNGLMAPBUFFERRANGEPROC glMapBufferRange;
extern PFNGLMAPNAMEDBUFFEREXTPROC glMapNamedBufferEXT;
extern PFNGLMAPNAMEDBUFFERPROC glMapNamedBuffer;
extern PFNGLMAPNAMEDBUFFERRANGEEXTPROC glMapNamedBufferRangeEXT;
extern PFNGLMAPNAMEDBUFFERRANGEPROC glMapNamedBufferRange;
extern PFNGLMATRIXFRUSTUMEXTPROC glMatrixFrustumEXT;
extern PFNGLMATRIXLOAD3X2FNVPROC glMatrixLoad3x2fNV;
extern PFNGLMATRIXLOAD3X3FNVPROC glMatrixLoad3x3fNV;
extern PFNGLMATRIXLOADDEXTPROC glMatrixLoaddEXT;
extern PFNGLMATRIXLOADFEXTPROC glMatrixLoadfEXT;
extern PFNGLMATRIXLOADIDENTITYEXTPROC glMatrixLoadIdentityEXT;
extern PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC glMatrixLoadTranspose3x3fNV;
extern PFNGLMATRIXLOADTRANSPOSEDEXTPROC glMatrixLoadTransposedEXT;
extern PFNGLMATRIXLOADTRANSPOSEFEXTPROC glMatrixLoadTransposefEXT;
extern PFNGLMATRIXMULT3X2FNVPROC glMatrixMult3x2fNV;
extern PFNGLMATRIXMULT3X3FNVPROC glMatrixMult3x3fNV;
extern PFNGLMATRIXMULTDEXTPROC glMatrixMultdEXT;
extern PFNGLMATRIXMULTFEXTPROC glMatrixMultfEXT;
extern PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC glMatrixMultTranspose3x3fNV;
extern PFNGLMATRIXMULTTRANSPOSEDEXTPROC glMatrixMultTransposedEXT;
extern PFNGLMATRIXMULTTRANSPOSEFEXTPROC glMatrixMultTransposefEXT;
extern PFNGLMATRIXORTHOEXTPROC glMatrixOrthoEXT;
extern PFNGLMATRIXPOPEXTPROC glMatrixPopEXT;
extern PFNGLMATRIXPUSHEXTPROC glMatrixPushEXT;
extern PFNGLMATRIXROTATEDEXTPROC glMatrixRotatedEXT;
extern PFNGLMATRIXROTATEFEXTPROC glMatrixRotatefEXT;
extern PFNGLMATRIXSCALEDEXTPROC glMatrixScaledEXT;
extern PFNGLMATRIXSCALEFEXTPROC glMatrixScalefEXT;
extern PFNGLMATRIXTRANSLATEDEXTPROC glMatrixTranslatedEXT;
extern PFNGLMATRIXTRANSLATEFEXTPROC glMatrixTranslatefEXT;
extern PFNGLMAXSHADERCOMPILERTHREADSARBPROC glMaxShaderCompilerThreadsARB;
extern PFNGLMEMORYBARRIERBYREGIONPROC glMemoryBarrierByRegion;
extern PFNGLMEMORYBARRIERPROC glMemoryBarrier;
extern PFNGLMINSAMPLESHADINGARBPROC glMinSampleShadingARB;
extern PFNGLMINSAMPLESHADINGPROC glMinSampleShading;
extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC glMultiDrawArraysIndirectBindlessCountNV;
extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC glMultiDrawArraysIndirectBindlessNV;
extern PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC glMultiDrawArraysIndirectCountARB;
extern PFNGLMULTIDRAWARRAYSINDIRECTPROC glMultiDrawArraysIndirect;
extern PFNGLMULTIDRAWARRAYSPROC glMultiDrawArrays;
extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glMultiDrawElementsBaseVertex;
extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC glMultiDrawElementsIndirectBindlessCountNV;
extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC glMultiDrawElementsIndirectBindlessNV;
extern PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC glMultiDrawElementsIndirectCountARB;
extern PFNGLMULTIDRAWELEMENTSINDIRECTPROC glMultiDrawElementsIndirect;
extern PFNGLMULTIDRAWELEMENTSPROC glMultiDrawElements;
extern PFNGLMULTITEXBUFFEREXTPROC glMultiTexBufferEXT;
extern PFNGLMULTITEXCOORDPOINTEREXTPROC glMultiTexCoordPointerEXT;
extern PFNGLMULTITEXENVFEXTPROC glMultiTexEnvfEXT;
extern PFNGLMULTITEXENVFVEXTPROC glMultiTexEnvfvEXT;
extern PFNGLMULTITEXENVIEXTPROC glMultiTexEnviEXT;
extern PFNGLMULTITEXENVIVEXTPROC glMultiTexEnvivEXT;
extern PFNGLMULTITEXGENDEXTPROC glMultiTexGendEXT;
extern PFNGLMULTITEXGENDVEXTPROC glMultiTexGendvEXT;
extern PFNGLMULTITEXGENFEXTPROC glMultiTexGenfEXT;
extern PFNGLMULTITEXGENFVEXTPROC glMultiTexGenfvEXT;
extern PFNGLMULTITEXGENIEXTPROC glMultiTexGeniEXT;
extern PFNGLMULTITEXGENIVEXTPROC glMultiTexGenivEXT;
extern PFNGLMULTITEXIMAGE1DEXTPROC glMultiTexImage1DEXT;
extern PFNGLMULTITEXIMAGE2DEXTPROC glMultiTexImage2DEXT;
extern PFNGLMULTITEXIMAGE3DEXTPROC glMultiTexImage3DEXT;
extern PFNGLMULTITEXPARAMETERFEXTPROC glMultiTexParameterfEXT;
extern PFNGLMULTITEXPARAMETERFVEXTPROC glMultiTexParameterfvEXT;
extern PFNGLMULTITEXPARAMETERIEXTPROC glMultiTexParameteriEXT;
extern PFNGLMULTITEXPARAMETERIIVEXTPROC glMultiTexParameterIivEXT;
extern PFNGLMULTITEXPARAMETERIUIVEXTPROC glMultiTexParameterIuivEXT;
extern PFNGLMULTITEXPARAMETERIVEXTPROC glMultiTexParameterivEXT;
extern PFNGLMULTITEXRENDERBUFFEREXTPROC glMultiTexRenderbufferEXT;
extern PFNGLMULTITEXSUBIMAGE1DEXTPROC glMultiTexSubImage1DEXT;
extern PFNGLMULTITEXSUBIMAGE2DEXTPROC glMultiTexSubImage2DEXT;
extern PFNGLMULTITEXSUBIMAGE3DEXTPROC glMultiTexSubImage3DEXT;
extern PFNGLNAMEDBUFFERDATAEXTPROC glNamedBufferDataEXT;
extern PFNGLNAMEDBUFFERDATAPROC glNamedBufferData;
extern PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC glNamedBufferPageCommitmentARB;
extern PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC glNamedBufferPageCommitmentEXT;
extern PFNGLNAMEDBUFFERSTORAGEEXTPROC glNamedBufferStorageEXT;
extern PFNGLNAMEDBUFFERSTORAGEPROC glNamedBufferStorage;
extern PFNGLNAMEDBUFFERSUBDATAEXTPROC glNamedBufferSubDataEXT;
extern PFNGLNAMEDBUFFERSUBDATAPROC glNamedBufferSubData;
extern PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC glNamedCopyBufferSubDataEXT;
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glNamedFramebufferDrawBuffer;
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glNamedFramebufferDrawBuffers;
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC glNamedFramebufferParameteriEXT;
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glNamedFramebufferParameteri;
extern PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glNamedFramebufferReadBuffer;
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC glNamedFramebufferRenderbufferEXT;
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glNamedFramebufferRenderbuffer;
extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glNamedFramebufferSampleLocationsfvARB;
extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glNamedFramebufferSampleLocationsfvNV;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC glNamedFramebufferTexture1DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC glNamedFramebufferTexture2DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC glNamedFramebufferTexture3DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC glNamedFramebufferTextureEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC glNamedFramebufferTextureFaceEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC glNamedFramebufferTextureLayerEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glNamedFramebufferTextureLayer;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glNamedFramebufferTexture;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC glNamedProgramLocalParameter4dEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC glNamedProgramLocalParameter4dvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC glNamedProgramLocalParameter4fEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC glNamedProgramLocalParameter4fvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC glNamedProgramLocalParameterI4iEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC glNamedProgramLocalParameterI4ivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC glNamedProgramLocalParameterI4uiEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC glNamedProgramLocalParameterI4uivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC glNamedProgramLocalParameters4fvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC glNamedProgramLocalParametersI4ivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC glNamedProgramLocalParametersI4uivEXT;
extern PFNGLNAMEDPROGRAMSTRINGEXTPROC glNamedProgramStringEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC glNamedRenderbufferStorageEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC glNamedRenderbufferStorageMultisampleCoverageEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glNamedRenderbufferStorageMultisampleEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glNamedRenderbufferStorageMultisample;
extern PFNGLNAMEDRENDERBUFFERSTORAGEPROC glNamedRenderbufferStorage;
extern PFNGLNAMEDSTRINGARBPROC glNamedStringARB;
extern PFNGLNORMALFORMATNVPROC glNormalFormatNV;
extern PFNGLOBJECTLABELPROC glObjectLabel;
extern PFNGLOBJECTPTRLABELPROC glObjectPtrLabel;
extern PFNGLPATCHPARAMETERFVPROC glPatchParameterfv;
extern PFNGLPATCHPARAMETERIPROC glPatchParameteri;
extern PFNGLPATHCOMMANDSNVPROC glPathCommandsNV;
extern PFNGLPATHCOORDSNVPROC glPathCoordsNV;
extern PFNGLPATHCOVERDEPTHFUNCNVPROC glPathCoverDepthFuncNV;
extern PFNGLPATHDASHARRAYNVPROC glPathDashArrayNV;
extern PFNGLPATHGLYPHINDEXARRAYNVPROC glPathGlyphIndexArrayNV;
extern PFNGLPATHGLYPHINDEXRANGENVPROC glPathGlyphIndexRangeNV;
extern PFNGLPATHGLYPHRANGENVPROC glPathGlyphRangeNV;
extern PFNGLPATHGLYPHSNVPROC glPathGlyphsNV;
extern PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC glPathMemoryGlyphIndexArrayNV;
extern PFNGLPATHPARAMETERFNVPROC glPathParameterfNV;
extern PFNGLPATHPARAMETERFVNVPROC glPathParameterfvNV;
extern PFNGLPATHPARAMETERINVPROC glPathParameteriNV;
extern PFNGLPATHPARAMETERIVNVPROC glPathParameterivNV;
extern PFNGLPATHSTENCILDEPTHOFFSETNVPROC glPathStencilDepthOffsetNV;
extern PFNGLPATHSTENCILFUNCNVPROC glPathStencilFuncNV;
extern PFNGLPATHSTRINGNVPROC glPathStringNV;
extern PFNGLPATHSUBCOMMANDSNVPROC glPathSubCommandsNV;
extern PFNGLPATHSUBCOORDSNVPROC glPathSubCoordsNV;
extern PFNGLPAUSETRANSFORMFEEDBACKPROC glPauseTransformFeedback;
extern PFNGLPIXELSTOREFPROC glPixelStoref;
extern PFNGLPIXELSTOREIPROC glPixelStorei;
extern PFNGLPOINTALONGPATHNVPROC glPointAlongPathNV;
extern PFNGLPOINTPARAMETERFPROC glPointParameterf;
extern PFNGLPOINTPARAMETERFVPROC glPointParameterfv;
extern PFNGLPOINTPARAMETERIPROC glPointParameteri;
extern PFNGLPOINTPARAMETERIVPROC glPointParameteriv;
extern PFNGLPOINTSIZEPROC glPointSize;
extern PFNGLPOLYGONMODEPROC glPolygonMode;
extern PFNGLPOLYGONOFFSETCLAMPEXTPROC glPolygonOffsetClampEXT;
extern PFNGLPOLYGONOFFSETPROC glPolygonOffset;
extern PFNGLPOPDEBUGGROUPPROC glPopDebugGroup;
extern PFNGLPOPGROUPMARKEREXTPROC glPopGroupMarkerEXT;
extern PFNGLPRIMITIVEBOUNDINGBOXARBPROC glPrimitiveBoundingBoxARB;
extern PFNGLPRIMITIVERESTARTINDEXPROC glPrimitiveRestartIndex;
extern PFNGLPROGRAMBINARYPROC glProgramBinary;
extern PFNGLPROGRAMPARAMETERIARBPROC glProgramParameteriARB;
extern PFNGLPROGRAMPARAMETERIPROC glProgramParameteri;
extern PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC glProgramPathFragmentInputGenNV;
extern PFNGLPROGRAMUNIFORM1DEXTPROC glProgramUniform1dEXT;
extern PFNGLPROGRAMUNIFORM1DPROC glProgramUniform1d;
extern PFNGLPROGRAMUNIFORM1DVEXTPROC glProgramUniform1dvEXT;
extern PFNGLPROGRAMUNIFORM1DVPROC glProgramUniform1dv;
extern PFNGLPROGRAMUNIFORM1FEXTPROC glProgramUniform1fEXT;
extern PFNGLPROGRAMUNIFORM1FPROC glProgramUniform1f;
extern PFNGLPROGRAMUNIFORM1FVEXTPROC glProgramUniform1fvEXT;
extern PFNGLPROGRAMUNIFORM1FVPROC glProgramUniform1fv;
extern PFNGLPROGRAMUNIFORM1I64ARBPROC glProgramUniform1i64ARB;
extern PFNGLPROGRAMUNIFORM1I64NVPROC glProgramUniform1i64NV;
extern PFNGLPROGRAMUNIFORM1I64VARBPROC glProgramUniform1i64vARB;
extern PFNGLPROGRAMUNIFORM1I64VNVPROC glProgramUniform1i64vNV;
extern PFNGLPROGRAMUNIFORM1IEXTPROC glProgramUniform1iEXT;
extern PFNGLPROGRAMUNIFORM1IPROC glProgramUniform1i;
extern PFNGLPROGRAMUNIFORM1IVEXTPROC glProgramUniform1ivEXT;
extern PFNGLPROGRAMUNIFORM1IVPROC glProgramUniform1iv;
extern PFNGLPROGRAMUNIFORM1UI64ARBPROC glProgramUniform1ui64ARB;
extern PFNGLPROGRAMUNIFORM1UI64NVPROC glProgramUniform1ui64NV;
extern PFNGLPROGRAMUNIFORM1UI64VARBPROC glProgramUniform1ui64vARB;
extern PFNGLPROGRAMUNIFORM1UI64VNVPROC glProgramUniform1ui64vNV;
extern PFNGLPROGRAMUNIFORM1UIEXTPROC glProgramUniform1uiEXT;
extern PFNGLPROGRAMUNIFORM1UIPROC glProgramUniform1ui;
extern PFNGLPROGRAMUNIFORM1UIVEXTPROC glProgramUniform1uivEXT;
extern PFNGLPROGRAMUNIFORM1UIVPROC glProgramUniform1uiv;
extern PFNGLPROGRAMUNIFORM2DEXTPROC glProgramUniform2dEXT;
extern PFNGLPROGRAMUNIFORM2DPROC glProgramUniform2d;
extern PFNGLPROGRAMUNIFORM2DVEXTPROC glProgramUniform2dvEXT;
extern PFNGLPROGRAMUNIFORM2DVPROC glProgramUniform2dv;
extern PFNGLPROGRAMUNIFORM2FEXTPROC glProgramUniform2fEXT;
extern PFNGLPROGRAMUNIFORM2FPROC glProgramUniform2f;
extern PFNGLPROGRAMUNIFORM2FVEXTPROC glProgramUniform2fvEXT;
extern PFNGLPROGRAMUNIFORM2FVPROC glProgramUniform2fv;
extern PFNGLPROGRAMUNIFORM2I64ARBPROC glProgramUniform2i64ARB;
extern PFNGLPROGRAMUNIFORM2I64NVPROC glProgramUniform2i64NV;
extern PFNGLPROGRAMUNIFORM2I64VARBPROC glProgramUniform2i64vARB;
extern PFNGLPROGRAMUNIFORM2I64VNVPROC glProgramUniform2i64vNV;
extern PFNGLPROGRAMUNIFORM2IEXTPROC glProgramUniform2iEXT;
extern PFNGLPROGRAMUNIFORM2IPROC glProgramUniform2i;
extern PFNGLPROGRAMUNIFORM2IVEXTPROC glProgramUniform2ivEXT;
extern PFNGLPROGRAMUNIFORM2IVPROC glProgramUniform2iv;
extern PFNGLPROGRAMUNIFORM2UI64ARBPROC glProgramUniform2ui64ARB;
extern PFNGLPROGRAMUNIFORM2UI64NVPROC glProgramUniform2ui64NV;
extern PFNGLPROGRAMUNIFORM2UI64VARBPROC glProgramUniform2ui64vARB;
extern PFNGLPROGRAMUNIFORM2UI64VNVPROC glProgramUniform2ui64vNV;
extern PFNGLPROGRAMUNIFORM2UIEXTPROC glProgramUniform2uiEXT;
extern PFNGLPROGRAMUNIFORM2UIPROC glProgramUniform2ui;
extern PFNGLPROGRAMUNIFORM2UIVEXTPROC glProgramUniform2uivEXT;
extern PFNGLPROGRAMUNIFORM2UIVPROC glProgramUniform2uiv;
extern PFNGLPROGRAMUNIFORM3DEXTPROC glProgramUniform3dEXT;
extern PFNGLPROGRAMUNIFORM3DPROC glProgramUniform3d;
extern PFNGLPROGRAMUNIFORM3DVEXTPROC glProgramUniform3dvEXT;
extern PFNGLPROGRAMUNIFORM3DVPROC glProgramUniform3dv;
extern PFNGLPROGRAMUNIFORM3FEXTPROC glProgramUniform3fEXT;
extern PFNGLPROGRAMUNIFORM3FPROC glProgramUniform3f;
extern PFNGLPROGRAMUNIFORM3FVEXTPROC glProgramUniform3fvEXT;
extern PFNGLPROGRAMUNIFORM3FVPROC glProgramUniform3fv;
extern PFNGLPROGRAMUNIFORM3I64ARBPROC glProgramUniform3i64ARB;
extern PFNGLPROGRAMUNIFORM3I64NVPROC glProgramUniform3i64NV;
extern PFNGLPROGRAMUNIFORM3I64VARBPROC glProgramUniform3i64vARB;
extern PFNGLPROGRAMUNIFORM3I64VNVPROC glProgramUniform3i64vNV;
extern PFNGLPROGRAMUNIFORM3IEXTPROC glProgramUniform3iEXT;
extern PFNGLPROGRAMUNIFORM3IPROC glProgramUniform3i;
extern PFNGLPROGRAMUNIFORM3IVEXTPROC glProgramUniform3ivEXT;
extern PFNGLPROGRAMUNIFORM3IVPROC glProgramUniform3iv;
extern PFNGLPROGRAMUNIFORM3UI64ARBPROC glProgramUniform3ui64ARB;
extern PFNGLPROGRAMUNIFORM3UI64NVPROC glProgramUniform3ui64NV;
extern PFNGLPROGRAMUNIFORM3UI64VARBPROC glProgramUniform3ui64vARB;
extern PFNGLPROGRAMUNIFORM3UI64VNVPROC glProgramUniform3ui64vNV;
extern PFNGLPROGRAMUNIFORM3UIEXTPROC glProgramUniform3uiEXT;
extern PFNGLPROGRAMUNIFORM3UIPROC glProgramUniform3ui;
extern PFNGLPROGRAMUNIFORM3UIVEXTPROC glProgramUniform3uivEXT;
extern PFNGLPROGRAMUNIFORM3UIVPROC glProgramUniform3uiv;
extern PFNGLPROGRAMUNIFORM4DEXTPROC glProgramUniform4dEXT;
extern PFNGLPROGRAMUNIFORM4DPROC glProgramUniform4d;
extern PFNGLPROGRAMUNIFORM4DVEXTPROC glProgramUniform4dvEXT;
extern PFNGLPROGRAMUNIFORM4DVPROC glProgramUniform4dv;
extern PFNGLPROGRAMUNIFORM4FEXTPROC glProgramUniform4fEXT;
extern PFNGLPROGRAMUNIFORM4FPROC glProgramUniform4f;
extern PFNGLPROGRAMUNIFORM4FVEXTPROC glProgramUniform4fvEXT;
extern PFNGLPROGRAMUNIFORM4FVPROC glProgramUniform4fv;
extern PFNGLPROGRAMUNIFORM4I64ARBPROC glProgramUniform4i64ARB;
extern PFNGLPROGRAMUNIFORM4I64NVPROC glProgramUniform4i64NV;
extern PFNGLPROGRAMUNIFORM4I64VARBPROC glProgramUniform4i64vARB;
extern PFNGLPROGRAMUNIFORM4I64VNVPROC glProgramUniform4i64vNV;
extern PFNGLPROGRAMUNIFORM4IEXTPROC glProgramUniform4iEXT;
extern PFNGLPROGRAMUNIFORM4IPROC glProgramUniform4i;
extern PFNGLPROGRAMUNIFORM4IVEXTPROC glProgramUniform4ivEXT;
extern PFNGLPROGRAMUNIFORM4IVPROC glProgramUniform4iv;
extern PFNGLPROGRAMUNIFORM4UI64ARBPROC glProgramUniform4ui64ARB;
extern PFNGLPROGRAMUNIFORM4UI64NVPROC glProgramUniform4ui64NV;
extern PFNGLPROGRAMUNIFORM4UI64VARBPROC glProgramUniform4ui64vARB;
extern PFNGLPROGRAMUNIFORM4UI64VNVPROC glProgramUniform4ui64vNV;
extern PFNGLPROGRAMUNIFORM4UIEXTPROC glProgramUniform4uiEXT;
extern PFNGLPROGRAMUNIFORM4UIPROC glProgramUniform4ui;
extern PFNGLPROGRAMUNIFORM4UIVEXTPROC glProgramUniform4uivEXT;
extern PFNGLPROGRAMUNIFORM4UIVPROC glProgramUniform4uiv;
extern PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC glProgramUniformHandleui64ARB;
extern PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC glProgramUniformHandleui64NV;
extern PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC glProgramUniformHandleui64vARB;
extern PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC glProgramUniformHandleui64vNV;
extern PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC glProgramUniformMatrix2dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2DVPROC glProgramUniformMatrix2dv;
extern PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC glProgramUniformMatrix2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2FVPROC glProgramUniformMatrix2fv;
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC glProgramUniformMatrix2x3dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glProgramUniformMatrix2x3dv;
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC glProgramUniformMatrix2x3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glProgramUniformMatrix2x3fv;
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC glProgramUniformMatrix2x4dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glProgramUniformMatrix2x4dv;
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC glProgramUniformMatrix2x4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glProgramUniformMatrix2x4fv;
extern PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC glProgramUniformMatrix3dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3DVPROC glProgramUniformMatrix3dv;
extern PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC glProgramUniformMatrix3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3FVPROC glProgramUniformMatrix3fv;
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC glProgramUniformMatrix3x2dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glProgramUniformMatrix3x2dv;
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC glProgramUniformMatrix3x2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glProgramUniformMatrix3x2fv;
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC glProgramUniformMatrix3x4dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glProgramUniformMatrix3x4dv;
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC glProgramUniformMatrix3x4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glProgramUniformMatrix3x4fv;
extern PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC glProgramUniformMatrix4dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4DVPROC glProgramUniformMatrix4dv;
extern PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC glProgramUniformMatrix4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4FVPROC glProgramUniformMatrix4fv;
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC glProgramUniformMatrix4x2dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glProgramUniformMatrix4x2dv;
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC glProgramUniformMatrix4x2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glProgramUniformMatrix4x2fv;
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC glProgramUniformMatrix4x3dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glProgramUniformMatrix4x3dv;
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC glProgramUniformMatrix4x3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glProgramUniformMatrix4x3fv;
extern PFNGLPROGRAMUNIFORMUI64NVPROC glProgramUniformui64NV;
extern PFNGLPROGRAMUNIFORMUI64VNVPROC glProgramUniformui64vNV;
extern PFNGLPROVOKINGVERTEXPROC glProvokingVertex;
extern PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC glPushClientAttribDefaultEXT;
extern PFNGLPUSHDEBUGGROUPPROC glPushDebugGroup;
extern PFNGLPUSHGROUPMARKEREXTPROC glPushGroupMarkerEXT;
extern PFNGLQUERYCOUNTERPROC glQueryCounter;
extern PFNGLRASTERSAMPLESEXTPROC glRasterSamplesEXT;
extern PFNGLREADBUFFERPROC glReadBuffer;
extern PFNGLREADNPIXELSARBPROC glReadnPixelsARB;
extern PFNGLREADNPIXELSPROC glReadnPixels;
extern PFNGLREADPIXELSPROC glReadPixels;
extern PFNGLRELEASESHADERCOMPILERPROC glReleaseShaderCompiler;
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC glRenderbufferStorageMultisampleCoverageNV;
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glRenderbufferStorageMultisample;
extern PFNGLRENDERBUFFERSTORAGEPROC glRenderbufferStorage;
extern PFNGLRESOLVEDEPTHVALUESNVPROC glResolveDepthValuesNV;
extern PFNGLRESUMETRANSFORMFEEDBACKPROC glResumeTransformFeedback;
extern PFNGLSAMPLECOVERAGEPROC glSampleCoverage;
extern PFNGLSAMPLEMASKIPROC glSampleMaski;
extern PFNGLSAMPLERPARAMETERFPROC glSamplerParameterf;
extern PFNGLSAMPLERPARAMETERFVPROC glSamplerParameterfv;
extern PFNGLSAMPLERPARAMETERIIVPROC glSamplerParameterIiv;
extern PFNGLSAMPLERPARAMETERIPROC glSamplerParameteri;
extern PFNGLSAMPLERPARAMETERIUIVPROC glSamplerParameterIuiv;
extern PFNGLSAMPLERPARAMETERIVPROC glSamplerParameteriv;
extern PFNGLSCISSORARRAYVPROC glScissorArrayv;
extern PFNGLSCISSORINDEXEDPROC glScissorIndexed;
extern PFNGLSCISSORINDEXEDVPROC glScissorIndexedv;
extern PFNGLSCISSORPROC glScissor;
extern PFNGLSECONDARYCOLORFORMATNVPROC glSecondaryColorFormatNV;
extern PFNGLSELECTPERFMONITORCOUNTERSAMDPROC glSelectPerfMonitorCountersAMD;
extern PFNGLSHADERBINARYPROC glShaderBinary;
extern PFNGLSHADERSOURCEPROC glShaderSource;
extern PFNGLSHADERSTORAGEBLOCKBINDINGPROC glShaderStorageBlockBinding;
extern PFNGLSIGNALVKFENCENVPROC glSignalVkFenceNV;
extern PFNGLSIGNALVKSEMAPHORENVPROC glSignalVkSemaphoreNV;
extern PFNGLSPECIALIZESHADERARBPROC glSpecializeShaderARB;
extern PFNGLSTATECAPTURENVPROC glStateCaptureNV;
extern PFNGLSTENCILFILLPATHINSTANCEDNVPROC glStencilFillPathInstancedNV;
extern PFNGLSTENCILFILLPATHNVPROC glStencilFillPathNV;
extern PFNGLSTENCILFUNCPROC glStencilFunc;
extern PFNGLSTENCILFUNCSEPARATEPROC glStencilFuncSeparate;
extern PFNGLSTENCILMASKPROC glStencilMask;
extern PFNGLSTENCILMASKSEPARATEPROC glStencilMaskSeparate;
extern PFNGLSTENCILOPPROC glStencilOp;
extern PFNGLSTENCILOPSEPARATEPROC glStencilOpSeparate;
extern PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC glStencilStrokePathInstancedNV;
extern PFNGLSTENCILSTROKEPATHNVPROC glStencilStrokePathNV;
extern PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC glStencilThenCoverFillPathInstancedNV;
extern PFNGLSTENCILTHENCOVERFILLPATHNVPROC glStencilThenCoverFillPathNV;
extern PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC glStencilThenCoverStrokePathInstancedNV;
extern PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC glStencilThenCoverStrokePathNV;
extern PFNGLSUBPIXELPRECISIONBIASNVPROC glSubpixelPrecisionBiasNV;
extern PFNGLTEXBUFFERARBPROC glTexBufferARB;
extern PFNGLTEXBUFFERPROC glTexBuffer;
extern PFNGLTEXBUFFERRANGEPROC glTexBufferRange;
extern PFNGLTEXCOORDFORMATNVPROC glTexCoordFormatNV;
extern PFNGLTEXIMAGE1DPROC glTexImage1D;
extern PFNGLTEXIMAGE2DMULTISAMPLEPROC glTexImage2DMultisample;
extern PFNGLTEXIMAGE2DPROC glTexImage2D;
extern PFNGLTEXIMAGE3DMULTISAMPLEPROC glTexImage3DMultisample;
extern PFNGLTEXIMAGE3DPROC glTexImage3D;
extern PFNGLTEXPAGECOMMITMENTARBPROC glTexPageCommitmentARB;
extern PFNGLTEXPARAMETERFPROC glTexParameterf;
extern PFNGLTEXPARAMETERFVPROC glTexParameterfv;
extern PFNGLTEXPARAMETERIIVPROC glTexParameterIiv;
extern PFNGLTEXPARAMETERIPROC glTexParameteri;
extern PFNGLTEXPARAMETERIUIVPROC glTexParameterIuiv;
extern PFNGLTEXPARAMETERIVPROC glTexParameteriv;
extern PFNGLTEXSTORAGE1DPROC glTexStorage1D;
extern PFNGLTEXSTORAGE2DMULTISAMPLEPROC glTexStorage2DMultisample;
extern PFNGLTEXSTORAGE2DPROC glTexStorage2D;
extern PFNGLTEXSTORAGE3DMULTISAMPLEPROC glTexStorage3DMultisample;
extern PFNGLTEXSTORAGE3DPROC glTexStorage3D;
extern PFNGLTEXSUBIMAGE1DPROC glTexSubImage1D;
extern PFNGLTEXSUBIMAGE2DPROC glTexSubImage2D;
extern PFNGLTEXSUBIMAGE3DPROC glTexSubImage3D;
extern PFNGLTEXTUREBARRIERNVPROC glTextureBarrierNV;
extern PFNGLTEXTUREBARRIERPROC glTextureBarrier;
extern PFNGLTEXTUREBUFFEREXTPROC glTextureBufferEXT;
extern PFNGLTEXTUREBUFFERPROC glTextureBuffer;
extern PFNGLTEXTUREBUFFERRANGEEXTPROC glTextureBufferRangeEXT;
extern PFNGLTEXTUREBUFFERRANGEPROC glTextureBufferRange;
extern PFNGLTEXTUREIMAGE1DEXTPROC glTextureImage1DEXT;
extern PFNGLTEXTUREIMAGE2DEXTPROC glTextureImage2DEXT;
extern PFNGLTEXTUREIMAGE3DEXTPROC glTextureImage3DEXT;
extern PFNGLTEXTUREPAGECOMMITMENTEXTPROC glTexturePageCommitmentEXT;
extern PFNGLTEXTUREPARAMETERFEXTPROC glTextureParameterfEXT;
extern PFNGLTEXTUREPARAMETERFPROC glTextureParameterf;
extern PFNGLTEXTUREPARAMETERFVEXTPROC glTextureParameterfvEXT;
extern PFNGLTEXTUREPARAMETERFVPROC glTextureParameterfv;
extern PFNGLTEXTUREPARAMETERIEXTPROC glTextureParameteriEXT;
extern PFNGLTEXTUREPARAMETERIIVEXTPROC glTextureParameterIivEXT;
extern PFNGLTEXTUREPARAMETERIIVPROC glTextureParameterIiv;
extern PFNGLTEXTUREPARAMETERIPROC glTextureParameteri;
extern PFNGLTEXTUREPARAMETERIUIVEXTPROC glTextureParameterIuivEXT;
extern PFNGLTEXTUREPARAMETERIUIVPROC glTextureParameterIuiv;
extern PFNGLTEXTUREPARAMETERIVEXTPROC glTextureParameterivEXT;
extern PFNGLTEXTUREPARAMETERIVPROC glTextureParameteriv;
extern PFNGLTEXTURERENDERBUFFEREXTPROC glTextureRenderbufferEXT;
extern PFNGLTEXTURESTORAGE1DEXTPROC glTextureStorage1DEXT;
extern PFNGLTEXTURESTORAGE1DPROC glTextureStorage1D;
extern PFNGLTEXTURESTORAGE2DEXTPROC glTextureStorage2DEXT;
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC glTextureStorage2DMultisampleEXT;
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glTextureStorage2DMultisample;
extern PFNGLTEXTURESTORAGE2DPROC glTextureStorage2D;
extern PFNGLTEXTURESTORAGE3DEXTPROC glTextureStorage3DEXT;
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC glTextureStorage3DMultisampleEXT;
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glTextureStorage3DMultisample;
extern PFNGLTEXTURESTORAGE3DPROC glTextureStorage3D;
extern PFNGLTEXTURESUBIMAGE1DEXTPROC glTextureSubImage1DEXT;
extern PFNGLTEXTURESUBIMAGE1DPROC glTextureSubImage1D;
extern PFNGLTEXTURESUBIMAGE2DEXTPROC glTextureSubImage2DEXT;
extern PFNGLTEXTURESUBIMAGE2DPROC glTextureSubImage2D;
extern PFNGLTEXTURESUBIMAGE3DEXTPROC glTextureSubImage3DEXT;
extern PFNGLTEXTURESUBIMAGE3DPROC glTextureSubImage3D;
extern PFNGLTEXTUREVIEWPROC glTextureView;
extern PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glTransformFeedbackBufferBase;
extern PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glTransformFeedbackBufferRange;
extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC glTransformFeedbackVaryings;
extern PFNGLTRANSFORMPATHNVPROC glTransformPathNV;
extern PFNGLUNIFORM1DPROC glUniform1d;
extern PFNGLUNIFORM1DVPROC glUniform1dv;
extern PFNGLUNIFORM1FPROC glUniform1f;
extern PFNGLUNIFORM1FVPROC glUniform1fv;
extern PFNGLUNIFORM1I64ARBPROC glUniform1i64ARB;
extern PFNGLUNIFORM1I64NVPROC glUniform1i64NV;
extern PFNGLUNIFORM1I64VARBPROC glUniform1i64vARB;
extern PFNGLUNIFORM1I64VNVPROC glUniform1i64vNV;
extern PFNGLUNIFORM1IPROC glUniform1i;
extern PFNGLUNIFORM1IVPROC glUniform1iv;
extern PFNGLUNIFORM1UI64ARBPROC glUniform1ui64ARB;
extern PFNGLUNIFORM1UI64NVPROC glUniform1ui64NV;
extern PFNGLUNIFORM1UI64VARBPROC glUniform1ui64vARB;
extern PFNGLUNIFORM1UI64VNVPROC glUniform1ui64vNV;
extern PFNGLUNIFORM1UIPROC glUniform1ui;
extern PFNGLUNIFORM1UIVPROC glUniform1uiv;
extern PFNGLUNIFORM2DPROC glUniform2d;
extern PFNGLUNIFORM2DVPROC glUniform2dv;
extern PFNGLUNIFORM2FPROC glUniform2f;
extern PFNGLUNIFORM2FVPROC glUniform2fv;
extern PFNGLUNIFORM2I64ARBPROC glUniform2i64ARB;
extern PFNGLUNIFORM2I64NVPROC glUniform2i64NV;
extern PFNGLUNIFORM2I64VARBPROC glUniform2i64vARB;
extern PFNGLUNIFORM2I64VNVPROC glUniform2i64vNV;
extern PFNGLUNIFORM2IPROC glUniform2i;
extern PFNGLUNIFORM2IVPROC glUniform2iv;
extern PFNGLUNIFORM2UI64ARBPROC glUniform2ui64ARB;
extern PFNGLUNIFORM2UI64NVPROC glUniform2ui64NV;
extern PFNGLUNIFORM2UI64VARBPROC glUniform2ui64vARB;
extern PFNGLUNIFORM2UI64VNVPROC glUniform2ui64vNV;
extern PFNGLUNIFORM2UIPROC glUniform2ui;
extern PFNGLUNIFORM2UIVPROC glUniform2uiv;
extern PFNGLUNIFORM3DPROC glUniform3d;
extern PFNGLUNIFORM3DVPROC glUniform3dv;
extern PFNGLUNIFORM3FPROC glUniform3f;
extern PFNGLUNIFORM3FVPROC glUniform3fv;
extern PFNGLUNIFORM3I64ARBPROC glUniform3i64ARB;
extern PFNGLUNIFORM3I64NVPROC glUniform3i64NV;
extern PFNGLUNIFORM3I64VARBPROC glUniform3i64vARB;
extern PFNGLUNIFORM3I64VNVPROC glUniform3i64vNV;
extern PFNGLUNIFORM3IPROC glUniform3i;
extern PFNGLUNIFORM3IVPROC glUniform3iv;
extern PFNGLUNIFORM3UI64ARBPROC glUniform3ui64ARB;
extern PFNGLUNIFORM3UI64NVPROC glUniform3ui64NV;
extern PFNGLUNIFORM3UI64VARBPROC glUniform3ui64vARB;
extern PFNGLUNIFORM3UI64VNVPROC glUniform3ui64vNV;
extern PFNGLUNIFORM3UIPROC glUniform3ui;
extern PFNGLUNIFORM3UIVPROC glUniform3uiv;
extern PFNGLUNIFORM4DPROC glUniform4d;
extern PFNGLUNIFORM4DVPROC glUniform4dv;
extern PFNGLUNIFORM4FPROC glUniform4f;
extern PFNGLUNIFORM4FVPROC glUniform4fv;
extern PFNGLUNIFORM4I64ARBPROC glUniform4i64ARB;
extern PFNGLUNIFORM4I64NVPROC glUniform4i64NV;
extern PFNGLUNIFORM4I64VARBPROC glUniform4i64vARB;
extern PFNGLUNIFORM4I64VNVPROC glUniform4i64vNV;
extern PFNGLUNIFORM4IPROC glUniform4i;
extern PFNGLUNIFORM4IVPROC glUniform4iv;
extern PFNGLUNIFORM4UI64ARBPROC glUniform4ui64ARB;
extern PFNGLUNIFORM4UI64NVPROC glUniform4ui64NV;
extern PFNGLUNIFORM4UI64VARBPROC glUniform4ui64vARB;
extern PFNGLUNIFORM4UI64VNVPROC glUniform4ui64vNV;
extern PFNGLUNIFORM4UIPROC glUniform4ui;
extern PFNGLUNIFORM4UIVPROC glUniform4uiv;
extern PFNGLUNIFORMBLOCKBINDINGPROC glUniformBlockBinding;
extern PFNGLUNIFORMHANDLEUI64ARBPROC glUniformHandleui64ARB;
extern PFNGLUNIFORMHANDLEUI64NVPROC glUniformHandleui64NV;
extern PFNGLUNIFORMHANDLEUI64VARBPROC glUniformHandleui64vARB;
extern PFNGLUNIFORMHANDLEUI64VNVPROC glUniformHandleui64vNV;
extern PFNGLUNIFORMMATRIX2DVPROC glUniformMatrix2dv;
extern PFNGLUNIFORMMATRIX2FVPROC glUniformMatrix2fv;
extern PFNGLUNIFORMMATRIX2X3DVPROC glUniformMatrix2x3dv;
extern PFNGLUNIFORMMATRIX2X3FVPROC glUniformMatrix2x3fv;
extern PFNGLUNIFORMMATRIX2X4DVPROC glUniformMatrix2x4dv;
extern PFNGLUNIFORMMATRIX2X4FVPROC glUniformMatrix2x4fv;
extern PFNGLUNIFORMMATRIX3DVPROC glUniformMatrix3dv;
extern PFNGLUNIFORMMATRIX3FVPROC glUniformMatrix3fv;
extern PFNGLUNIFORMMATRIX3X2DVPROC glUniformMatrix3x2dv;
extern PFNGLUNIFORMMATRIX3X2FVPROC glUniformMatrix3x2fv;
extern PFNGLUNIFORMMATRIX3X4DVPROC glUniformMatrix3x4dv;
extern PFNGLUNIFORMMATRIX3X4FVPROC glUniformMatrix3x4fv;
extern PFNGLUNIFORMMATRIX4DVPROC glUniformMatrix4dv;
extern PFNGLUNIFORMMATRIX4FVPROC glUniformMatrix4fv;
extern PFNGLUNIFORMMATRIX4X2DVPROC glUniformMatrix4x2dv;
extern PFNGLUNIFORMMATRIX4X2FVPROC glUniformMatrix4x2fv;
extern PFNGLUNIFORMMATRIX4X3DVPROC glUniformMatrix4x3dv;
extern PFNGLUNIFORMMATRIX4X3FVPROC glUniformMatrix4x3fv;
extern PFNGLUNIFORMSUBROUTINESUIVPROC glUniformSubroutinesuiv;
extern PFNGLUNIFORMUI64NVPROC glUniformui64NV;
extern PFNGLUNIFORMUI64VNVPROC glUniformui64vNV;
extern PFNGLUNMAPBUFFERPROC glUnmapBuffer;
extern PFNGLUNMAPNAMEDBUFFEREXTPROC glUnmapNamedBufferEXT;
extern PFNGLUNMAPNAMEDBUFFERPROC glUnmapNamedBuffer;
extern PFNGLUSEPROGRAMPROC glUseProgram;
extern PFNGLUSEPROGRAMSTAGESPROC glUseProgramStages;
extern PFNGLUSESHADERPROGRAMEXTPROC glUseShaderProgramEXT;
extern PFNGLVALIDATEPROGRAMPIPELINEPROC glValidateProgramPipeline;
extern PFNGLVALIDATEPROGRAMPROC glValidateProgram;
extern PFNGLVERTEXARRAYATTRIBBINDINGPROC glVertexArrayAttribBinding;
extern PFNGLVERTEXARRAYATTRIBFORMATPROC glVertexArrayAttribFormat;
extern PFNGLVERTEXARRAYATTRIBIFORMATPROC glVertexArrayAttribIFormat;
extern PFNGLVERTEXARRAYATTRIBLFORMATPROC glVertexArrayAttribLFormat;
extern PFNGLVERTEXARRAYBINDINGDIVISORPROC glVertexArrayBindingDivisor;
extern PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC glVertexArrayBindVertexBufferEXT;
extern PFNGLVERTEXARRAYCOLOROFFSETEXTPROC glVertexArrayColorOffsetEXT;
extern PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC glVertexArrayEdgeFlagOffsetEXT;
extern PFNGLVERTEXARRAYELEMENTBUFFERPROC glVertexArrayElementBuffer;
extern PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC glVertexArrayFogCoordOffsetEXT;
extern PFNGLVERTEXARRAYINDEXOFFSETEXTPROC glVertexArrayIndexOffsetEXT;
extern PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC glVertexArrayMultiTexCoordOffsetEXT;
extern PFNGLVERTEXARRAYNORMALOFFSETEXTPROC glVertexArrayNormalOffsetEXT;
extern PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC glVertexArraySecondaryColorOffsetEXT;
extern PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC glVertexArrayTexCoordOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC glVertexArrayVertexAttribBindingEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC glVertexArrayVertexAttribDivisorEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC glVertexArrayVertexAttribFormatEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC glVertexArrayVertexAttribIFormatEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC glVertexArrayVertexAttribIOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC glVertexArrayVertexAttribLFormatEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC glVertexArrayVertexAttribLOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC glVertexArrayVertexAttribOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC glVertexArrayVertexBindingDivisorEXT;
extern PFNGLVERTEXARRAYVERTEXBUFFERPROC glVertexArrayVertexBuffer;
extern PFNGLVERTEXARRAYVERTEXBUFFERSPROC glVertexArrayVertexBuffers;
extern PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC glVertexArrayVertexOffsetEXT;
extern PFNGLVERTEXATTRIB1DPROC glVertexAttrib1d;
extern PFNGLVERTEXATTRIB1DVPROC glVertexAttrib1dv;
extern PFNGLVERTEXATTRIB1FPROC glVertexAttrib1f;
extern PFNGLVERTEXATTRIB1FVPROC glVertexAttrib1fv;
extern PFNGLVERTEXATTRIB1SPROC glVertexAttrib1s;
extern PFNGLVERTEXATTRIB1SVPROC glVertexAttrib1sv;
extern PFNGLVERTEXATTRIB2DPROC glVertexAttrib2d;
extern PFNGLVERTEXATTRIB2DVPROC glVertexAttrib2dv;
extern PFNGLVERTEXATTRIB2FPROC glVertexAttrib2f;
extern PFNGLVERTEXATTRIB2FVPROC glVertexAttrib2fv;
extern PFNGLVERTEXATTRIB2SPROC glVertexAttrib2s;
extern PFNGLVERTEXATTRIB2SVPROC glVertexAttrib2sv;
extern PFNGLVERTEXATTRIB3DPROC glVertexAttrib3d;
extern PFNGLVERTEXATTRIB3DVPROC glVertexAttrib3dv;
extern PFNGLVERTEXATTRIB3FPROC glVertexAttrib3f;
extern PFNGLVERTEXATTRIB3FVPROC glVertexAttrib3fv;
extern PFNGLVERTEXATTRIB3SPROC glVertexAttrib3s;
extern PFNGLVERTEXATTRIB3SVPROC glVertexAttrib3sv;
extern PFNGLVERTEXATTRIB4BVPROC glVertexAttrib4bv;
extern PFNGLVERTEXATTRIB4DPROC glVertexAttrib4d;
extern PFNGLVERTEXATTRIB4DVPROC glVertexAttrib4dv;
extern PFNGLVERTEXATTRIB4FPROC glVertexAttrib4f;
extern PFNGLVERTEXATTRIB4FVPROC glVertexAttrib4fv;
extern PFNGLVERTEXATTRIB4IVPROC glVertexAttrib4iv;
extern PFNGLVERTEXATTRIB4NBVPROC glVertexAttrib4Nbv;
extern PFNGLVERTEXATTRIB4NIVPROC glVertexAttrib4Niv;
extern PFNGLVERTEXATTRIB4NSVPROC glVertexAttrib4Nsv;
extern PFNGLVERTEXATTRIB4NUBPROC glVertexAttrib4Nub;
extern PFNGLVERTEXATTRIB4NUBVPROC glVertexAttrib4Nubv;
extern PFNGLVERTEXATTRIB4NUIVPROC glVertexAttrib4Nuiv;
extern PFNGLVERTEXATTRIB4NUSVPROC glVertexAttrib4Nusv;
extern PFNGLVERTEXATTRIB4SPROC glVertexAttrib4s;
extern PFNGLVERTEXATTRIB4SVPROC glVertexAttrib4sv;
extern PFNGLVERTEXATTRIB4UBVPROC glVertexAttrib4ubv;
extern PFNGLVERTEXATTRIB4UIVPROC glVertexAttrib4uiv;
extern PFNGLVERTEXATTRIB4USVPROC glVertexAttrib4usv;
extern PFNGLVERTEXATTRIBBINDINGPROC glVertexAttribBinding;
extern PFNGLVERTEXATTRIBDIVISORARBPROC glVertexAttribDivisorARB;
extern PFNGLVERTEXATTRIBDIVISORPROC glVertexAttribDivisor;
extern PFNGLVERTEXATTRIBFORMATNVPROC glVertexAttribFormatNV;
extern PFNGLVERTEXATTRIBFORMATPROC glVertexAttribFormat;
extern PFNGLVERTEXATTRIBI1IPROC glVertexAttribI1i;
extern PFNGLVERTEXATTRIBI1IVPROC glVertexAttribI1iv;
extern PFNGLVERTEXATTRIBI1UIPROC glVertexAttribI1ui;
extern PFNGLVERTEXATTRIBI1UIVPROC glVertexAttribI1uiv;
extern PFNGLVERTEXATTRIBI2IPROC glVertexAttribI2i;
extern PFNGLVERTEXATTRIBI2IVPROC glVertexAttribI2iv;
extern PFNGLVERTEXATTRIBI2UIPROC glVertexAttribI2ui;
extern PFNGLVERTEXATTRIBI2UIVPROC glVertexAttribI2uiv;
extern PFNGLVERTEXATTRIBI3IPROC glVertexAttribI3i;
extern PFNGLVERTEXATTRIBI3IVPROC glVertexAttribI3iv;
extern PFNGLVERTEXATTRIBI3UIPROC glVertexAttribI3ui;
extern PFNGLVERTEXATTRIBI3UIVPROC glVertexAttribI3uiv;
extern PFNGLVERTEXATTRIBI4BVPROC glVertexAttribI4bv;
extern PFNGLVERTEXATTRIBI4IPROC glVertexAttribI4i;
extern PFNGLVERTEXATTRIBI4IVPROC glVertexAttribI4iv;
extern PFNGLVERTEXATTRIBI4SVPROC glVertexAttribI4sv;
extern PFNGLVERTEXATTRIBI4UBVPROC glVertexAttribI4ubv;
extern PFNGLVERTEXATTRIBI4UIPROC glVertexAttribI4ui;
extern PFNGLVERTEXATTRIBI4UIVPROC glVertexAttribI4uiv;
extern PFNGLVERTEXATTRIBI4USVPROC glVertexAttribI4usv;
extern PFNGLVERTEXATTRIBIFORMATNVPROC glVertexAttribIFormatNV;
extern PFNGLVERTEXATTRIBIFORMATPROC glVertexAttribIFormat;
extern PFNGLVERTEXATTRIBIPOINTERPROC glVertexAttribIPointer;
extern PFNGLVERTEXATTRIBL1DPROC glVertexAttribL1d;
extern PFNGLVERTEXATTRIBL1DVPROC glVertexAttribL1dv;
extern PFNGLVERTEXATTRIBL1I64NVPROC glVertexAttribL1i64NV;
extern PFNGLVERTEXATTRIBL1I64VNVPROC glVertexAttribL1i64vNV;
extern PFNGLVERTEXATTRIBL1UI64ARBPROC glVertexAttribL1ui64ARB;
extern PFNGLVERTEXATTRIBL1UI64NVPROC glVertexAttribL1ui64NV;
extern PFNGLVERTEXATTRIBL1UI64VARBPROC glVertexAttribL1ui64vARB;
extern PFNGLVERTEXATTRIBL1UI64VNVPROC glVertexAttribL1ui64vNV;
extern PFNGLVERTEXATTRIBL2DPROC glVertexAttribL2d;
extern PFNGLVERTEXATTRIBL2DVPROC glVertexAttribL2dv;
extern PFNGLVERTEXATTRIBL2I64NVPROC glVertexAttribL2i64NV;
extern PFNGLVERTEXATTRIBL2I64VNVPROC glVertexAttribL2i64vNV;
extern PFNGLVERTEXATTRIBL2UI64NVPROC glVertexAttribL2ui64NV;
extern PFNGLVERTEXATTRIBL2UI64VNVPROC glVertexAttribL2ui64vNV;
extern PFNGLVERTEXATTRIBL3DPROC glVertexAttribL3d;
extern PFNGLVERTEXATTRIBL3DVPROC glVertexAttribL3dv;
extern PFNGLVERTEXATTRIBL3I64NVPROC glVertexAttribL3i64NV;
extern PFNGLVERTEXATTRIBL3I64VNVPROC glVertexAttribL3i64vNV;
extern PFNGLVERTEXATTRIBL3UI64NVPROC glVertexAttribL3ui64NV;
extern PFNGLVERTEXATTRIBL3UI64VNVPROC glVertexAttribL3ui64vNV;
extern PFNGLVERTEXATTRIBL4DPROC glVertexAttribL4d;
extern PFNGLVERTEXATTRIBL4DVPROC glVertexAttribL4dv;
extern PFNGLVERTEXATTRIBL4I64NVPROC glVertexAttribL4i64NV;
extern PFNGLVERTEXATTRIBL4I64VNVPROC glVertexAttribL4i64vNV;
extern PFNGLVERTEXATTRIBL4UI64NVPROC glVertexAttribL4ui64NV;
extern PFNGLVERTEXATTRIBL4UI64VNVPROC glVertexAttribL4ui64vNV;
extern PFNGLVERTEXATTRIBLFORMATNVPROC glVertexAttribLFormatNV;
extern PFNGLVERTEXATTRIBLFORMATPROC glVertexAttribLFormat;
extern PFNGLVERTEXATTRIBLPOINTERPROC glVertexAttribLPointer;
extern PFNGLVERTEXATTRIBP1UIPROC glVertexAttribP1ui;
extern PFNGLVERTEXATTRIBP1UIVPROC glVertexAttribP1uiv;
extern PFNGLVERTEXATTRIBP2UIPROC glVertexAttribP2ui;
extern PFNGLVERTEXATTRIBP2UIVPROC glVertexAttribP2uiv;
extern PFNGLVERTEXATTRIBP3UIPROC glVertexAttribP3ui;
extern PFNGLVERTEXATTRIBP3UIVPROC glVertexAttribP3uiv;
extern PFNGLVERTEXATTRIBP4UIPROC glVertexAttribP4ui;
extern PFNGLVERTEXATTRIBP4UIVPROC glVertexAttribP4uiv;
extern PFNGLVERTEXATTRIBPOINTERPROC glVertexAttribPointer;
extern PFNGLVERTEXBINDINGDIVISORPROC glVertexBindingDivisor;
extern PFNGLVERTEXFORMATNVPROC glVertexFormatNV;
extern PFNGLVIEWPORTARRAYVPROC glViewportArrayv;
extern PFNGLVIEWPORTINDEXEDFPROC glViewportIndexedf;
extern PFNGLVIEWPORTINDEXEDFVPROC glViewportIndexedfv;
extern PFNGLVIEWPORTPOSITIONWSCALENVPROC glViewportPositionWScaleNV;
extern PFNGLVIEWPORTPROC glViewport;
extern PFNGLVIEWPORTSWIZZLENVPROC glViewportSwizzleNV;
extern PFNGLWAITSYNCPROC glWaitSync;
extern PFNGLWAITVKSEMAPHORENVPROC glWaitVkSemaphoreNV;
extern PFNGLWEIGHTPATHSNVPROC glWeightPathsNV;
extern PFNGLWINDOWRECTANGLESEXTPROC glWindowRectanglesEXT;
#endif

/// @endcond

///
/// ゲームグラフィックス特論の宿題用補助プログラムの名前空間
///
namespace gg
{
  ///
  /// 光源と材質の uniform buffer object の結合ポイント.
  ///
  enum BindingPoints
  {
    LightBindingPoint = 0,  ///< @brief 光源の uniform buffer object の結合ポイント.
    MaterialBindingPoint,   ///< @brief 材質の uniform buffer object の結合ポイント.
  };

  ///
  /// 使用している GPU のバッファオブジェクトのアライメント, 初期化に取得される.
  ///
  extern GLint ggBufferAlignment;

  ///
  /// ゲームグラフィックス特論の都合にもとづく初期化を行う.
  ///
  /// @note
  /// Windows において OpenGL 1.2 以降の API を有効化する.
  ///
  extern void ggInit();

  ///
  /// OpenGL のエラーをチェックする.
  ///
  /// @param name エラー発生時に標準エラー出力に出力する文字列, nullptr なら何も出力しない.
  /// @param line エラー発生時に標準エラー出力に出力する数値, 0 なら何も出力しない.
  ///
  /// @note
  /// OpenGL の API を呼び出し直後に実行すればエラーのあるときにメッセージを表示する.
  ///
  extern void _ggError(const std::string& name = "", unsigned int line = 0);

  ///
  /// OpenGL のエラーの発生を検知したときにソースファイル名と行番号を表示する.
  ///
  /// @def ggError()
  ///
  /// @note
  /// このマクロを置いた場所（より前）で OpenGL のエラーが発生していた時に,
  /// このマクロを置いたソースファイル名と行番号を出力する.
  /// リリースビルド時には無視される.
  ///
#if defined(DEBUG)
#  define ggError() gg::_ggError(__FILE__, __LINE__)
#else
#  define ggError()
#endif

  ///
  /// FBO のエラーをチェックする.
  ///
  /// @param name エラー発生時に標準エラー出力に出力する文字列, nullptr なら何も出力しない.
  /// @param line エラー発生時に標準エラー出力に出力する数値, 0 なら何も出力しない.
  ///
  /// @note
  /// FBO の API を呼び出し直後に実行すればエラーのあるときにメッセージを表示する.
  ///
  extern void _ggFBOError(const std::string& name = "", unsigned int line = 0);

  ///
  /// FBO のエラーの発生を検知したときにソースファイル名と行番号を表示する.
  ///
  /// @def ggFBOError()
  ///
  /// @note
  /// このマクロを置いた場所（より前）で FBO のエラーが発生していた時に,
  /// このマクロを置いたソースファイル名と行番号を出力する.
  /// リリースビルド時には無視される.
  ///
#if defined(DEBUG)
#  define ggFBOError() gg::_ggFBOError(__FILE__, __LINE__)
#else
#  define ggFBOError()
#endif

  ///
  /// 3 要素の外積.
  ///
  /// @param a GLfloat 型の 3 要素の配列変数.
  /// @param b GLfloat 型の 3 要素の配列変数.
  /// @param c 結果を格納する GLfloat 型の 3 要素の配列変数.
  ///
  inline void ggCross(GLfloat* c, const GLfloat* a, const GLfloat* b)
  {
    c[0] = a[1] * b[2] - a[2] * b[1];
    c[1] = a[2] * b[0] - a[0] * b[2];
    c[2] = a[0] * b[1] - a[1] * b[0];
  }

  ///
  /// 3 要素の内積.
  ///
  /// @param a GLfloat 型の 3 要素の配列変数.
  /// @param b GLfloat 型の 3 要素の配列変数.
  /// @return a と b のそれぞれの 3 要素の内積.
  ///
  inline GLfloat ggDot3(const GLfloat* a, const GLfloat* b)
  {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }

  ///
  /// 3 要素の長さ.
  ///
  /// @param a GLfloat 型の 3 要素の配列変数.
  /// @return a の 3 要素の長さ.
  ///
  inline GLfloat ggLength3(const GLfloat* a)
  {
    return sqrtf(ggDot3(a, a));
  }

  ///
  /// 3 要素の距離.
  ///
  /// @param a GLfloat 型の 3 要素の配列変数.
  /// @param b GLfloat 型の 3 要素の配列変数.
  /// @return a と b の距離.
  ///
  inline GLfloat ggDistance3(const GLfloat* a, const GLfloat* b)
  {
    const GLfloat c[]{ a[0] - b[0], a[1] - b[1], a[2] - b[2], 0.0f };
    return ggLength3(c);
  }

  ///
  /// 3 要素の正規化.
  ///
  /// @param a GLfloat 型の 3 要素の配列変数.
  /// @param b a の 3 要素を正規化した結果を格納する GLfloat 型の 3 要素の配列変数.
  ///
  inline void ggNormalize3(const GLfloat* a, GLfloat* b)
  {
    const GLfloat l{ ggLength3(a) };
    b[0] = a[0] / l;
    b[1] = a[1] / l;
    b[2] = a[2] / l;
  }

  ///
  /// 3 要素の正規化.
  ///
  /// @param a GLfloat 型の 3 要素の配列変数.
  ///
  inline void ggNormalize3(GLfloat* a)
  {
    const GLfloat l{ ggLength3(a) };
    a[0] /= l;
    a[1] /= l;
    a[2] /= l;
  }

  ///
  /// GLfloat 型の 4 要素の内積
  ///
  /// @param a GLfloat 型の 4 要素の配列変数.
  /// @param b GLfloat 型の 4 要素の配列変数.
  /// @return a と b のそれぞれの 4 要素の内積.
  ///
  inline GLfloat ggDot4(const GLfloat* a, const GLfloat* b)
  {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }

  ///
  /// GLfloat 型の 4 要素の長さ.
  ///
  /// @param a GLfloat 型の 4 要素の配列変数.
  /// @return a の 4 要素の長さ.
  ///
  inline GLfloat ggLength4(const GLfloat* a)
  {
    return sqrtf(ggDot4(a, a));
  }

  ///
  /// GLfloat 型の 4 要素の距離.
  ///
  /// @param a GLfloat 型の 4 要素の配列変数.
  /// @param b GLfloat 型の 4 要素の配列変数.
  /// @return a と b のそれぞれの 4 要素の距離.
  ///
  inline GLfloat ggDistance4(const GLfloat* a, const GLfloat* b)
  {
    const GLfloat c[]{ a[0] - b[0], a[1] - b[1], a[2] - b[2], a[3] - b[3] };
    return ggLength4(c);
  }

  ///
  /// GLfloat 型の 4 要素の正規化.
  ///
  /// @param a GLfloat 型の 4 要素の配列変数.
  /// @param b a を正規化した結果を格納する GLfloat 型の 4 要素の配列変数.
  ///
  inline void ggNormalize4(const GLfloat* a, GLfloat* b)
  {
    const GLfloat l{ ggLength4(a) };
    b[0] = a[0] / l;
    b[1] = a[1] / l;
    b[2] = a[2] / l;
    b[3] = a[3] / l;
  }

  ///
  /// GLfloat 型の 4 要素の正規化.
  ///
  /// @param a 正規化する GLfloat 型の 4 要素の配列変数.
  ///
  inline void ggNormalize4(GLfloat* a)
  {
    const GLfloat l{ ggLength4(a) };
    a[0] /= l;
    a[1] /= l;
    a[2] /= l;
    a[3] /= l;
  }

  ///
  /// 4 要素の単精度実数の配列.
  ///
  class GgVector : public std::array<GLfloat, 4>
  {
  public:

    ///
    /// コンストラクタ.
    ///
    GgVector()
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param v0 GLfloat 型の値.
    /// @param v1 GLfloat 型の値.
    /// @param v2 GLfloat 型の値.
    /// @param v3 GLfloat 型の値.
    ///
    constexpr GgVector(GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) :
      std::array<GLfloat, 4>{ v0, v1, v2, v3 }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param c GLfloat 型の値.
    ///
    constexpr GgVector(GLfloat c) :
      GgVector{ c, c, c, c }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param a GLfloat 型の 4 要素の配列変数.
    ///
    constexpr GgVector(const GLfloat* a) :
      GgVector{ a[0], a[1], a[2], a[3] }
    {
    }

    ///
    /// GgVector 型の和を返す.
    ///
    /// @param v GgVector 型のベクトル.
    /// @return オブジェクトの各要素と v の各要素の要素ごとの和のオブジェクト.
    ///
    GgVector operator+(const GgVector& v) const
    {
      return GgVector{ data()[0] + v[0], data()[1] + v[1], data()[2] + v[2], data()[3] + v[3] };
    }

    ///
    /// GgVector 型の各要素にスカラーを足した和を返す.
    ///
    /// @param c GLfloat 型の値.
    /// @return a の各要素に b を足した和のオブジェクト.
    ///
    GgVector operator+(GLfloat c) const
    {
      return GgVector{ data()[0] + c, data()[1] + c, data()[2] + c, data()[3] + c };
    }

    ///
    /// GgVector 型を加算する.
    ///
    /// @param v GgVector 型の変数.
    /// @return オブジェクトの各要素に v の各要素をそれぞれ加算したオブジェクトの参照.
    ///
    GgVector& operator+=(const GgVector& v)
    {
      data()[0] += v[0];
      data()[1] += v[1];
      data()[2] += v[2];
      data()[3] += v[3];
      return *this;
    }

    ///
    /// GgVector 型の各要素にスカラーを加算する.
    ///
    /// @param c GLfloat 型の値.
    /// @return オブジェクトの各要素に c を足したオブジェクトの参照.
    ///
    GgVector& operator+=(GLfloat c)
    {
      data()[0] += c;
      data()[1] += c;
      data()[2] += c;
      data()[3] += c;
      return *this;
    }

    ///
    /// GgVector 型の差を返す.
    ///
    /// @param v GgVector 型の変数.
    /// @return オブジェクトの各要素と v の各要素の要素ごとの差のオブジェクト.
    ///
    GgVector operator-(const GgVector& v) const
    {
      return GgVector{ data()[0] - v[0], data()[1] - v[1], data()[2] - v[2], data()[3] - v[3] };
    }

    ///
    /// GgVector 型の各要素からスカラーを引いた差を返す.
    ///
    /// @param c GLfloat 型の変数.
    /// @return オブジェクトの各要素から c を引いたオブジェクト.
    ///
    GgVector operator-(GLfloat c) const
    {
      return GgVector{ data()[0] - c, data()[1] - c, data()[2] - c, data()[3] - c };
    }

    ///
    /// GgVector 型を減算する.
    ///
    /// @param v GgVector 型の変数.
    /// @return オブジェクトの各要素に v の各要素をそれぞれ減算したオブジェクトの参照.
    ///
    GgVector& operator-=(const GgVector& v)
    {
      data()[0] -= v[0];
      data()[1] -= v[1];
      data()[2] -= v[2];
      data()[3] -= v[3];
      return *this;
    }

    ///
    /// GgVector 型の各要素からスカラーを引く.
    ///
    /// @param c GLfloat 型の変数.
    /// @return オブジェクトの各要素から c を引いたオブジェクトの参照.
    ///
    GgVector& operator-=(GLfloat c)
    {
      data()[0] -= c;
      data()[1] -= c;
      data()[2] -= c;
      data()[3] -= c;
      return *this;
    }

    ///
    /// GgVector 型の積を返す.
    ///
    /// @param v GgVector 型の変数.
    /// @return オブジェクトの各要素と v の各要素の要素ごとの積のオブジェクト.
    ///
    GgVector operator*(const GgVector& v) const
    {
      return GgVector{ data()[0] * v[0], data()[1] * v[1], data()[2] * v[2], data()[3] * v[3] };
    }

    ///
    /// GgVector 型の各要素にスカラーを乗じた積を返す.
    ///
    /// @param c GLfloat 型の変数.
    /// @return オブジェクトの各要素に c を乗じたオブジェクト.
    ///
    GgVector operator*(GLfloat c) const
    {
      return GgVector{ data()[0] * c, data()[1] * c, data()[2] * c, data()[3] * c };
    }

    ///
    /// GgVector 型を乗算する.
    ///
    /// @param v GgVector 型の変数.
    /// @return オブジェクトの各要素に v の各要素をそれぞれ乗算したオブジェクトの参照.
    GgVector& operator*=(const GgVector& v)
    {
      data()[0] *= v[0];
      data()[1] *= v[1];
      data()[2] *= v[2];
      data()[3] *= v[3];
      return *this;
    }

    ///
    /// GgVector 型の各要素にスカラーを乗じる.
    ///
    /// @param c GgVector 型のベクトル.
    /// @return オブジェクトの各要素に c を乗じたオブジェクトの参照.
    ///
    GgVector& operator*=(GLfloat c)
    {
      data()[0] *= c;
      data()[1] *= c;
      data()[2] *= c;
      data()[3] *= c;
      return *this;
    }

    ///
    /// GgVector 型の商を返す.
    ///
    /// @param v GgVector 型の変数.
    /// @return オブジェクトの各要素を v の各要素で要素ごとに割った結果のオブジェクト.
    ///
    GgVector operator/(const GgVector& v) const
    {
      return GgVector{ data()[0] / v[0], data()[1] / v[1], data()[2] / v[2], data()[3] / v[3] };
    }

    ///
    /// GgVector 型を除算する.
    ///
    /// @param v GgVector 型の変数.
    /// @return オブジェクトの各要素に v の各要素をそれぞれ乗算したオブジェクトの参照.
    ///
    GgVector& operator/=(GgVector& v)
    {
      data()[0] /= v[0];
      data()[1] /= v[1];
      data()[2] /= v[2];
      data()[3] /= v[3];
      return *this;
    }

    ///
    /// GgVector 型の各要素をスカラーで割った商を返す.
    ///
    /// @param c GLfloat 型の値.
    /// @return オブジェクトの各要素を c で割った商のオブジェクト.
    ///
    GgVector operator/(GLfloat c) const
    {
      return GgVector{ data()[0] / c, data()[1] / c, data()[2] / c, data()[3] / c };
    }

    ///
    /// GgVector 型の各要素をスカラーで割る.
    ///
    /// @param c GLfloat 型の変数.
    /// @return オブジェクトの各要素を c で割ったオブジェクトの参照.
    ///
    GgVector& operator/=(GLfloat c)
    {
      data()[0] /= c;
      data()[1] /= c;
      data()[2] /= c;
      data()[3] /= c;
      return *this;
    }

    ///
    /// GgVector 型の 3 要素の内積.
    ///
    /// @param v GgVector 型のベクトル.
    /// @return オブジェクトと v のそれぞれの 3 要素の内積.
    ///
    GLfloat dot3(const GgVector& v) const
    {
      return ggDot3(data(), v.data());
    }

    ///
    /// GgVector 型の 3 要素の長さ.
    ///
    /// @return オブジェクトの 4 要素の長さ.
    ///
    GLfloat length3() const
    {
      return ggLength3(data());
    }

    ///
    /// GgVector 型の 3 要素の距離.
    ///
    /// @param v GgVector 型のベクトル.
    /// @return オブジェクトと v の 3 要素の距離.
    ///
    GLfloat distance3(const GgVector& v) const
    {
      return ggDistance3(data(), v.data());
    }

    ///
    /// GgVector 型の 4 要素の正規化.
    ///
    /// @return GLfloat 型の 4 要素の配列変数.
    ///
    GgVector normalize3() const
    {
      GgVector b;
      ggNormalize3(data(), b.data());
      return b;
    }

    ///
    /// GgVector 型の 4 要素の内積.
    ///
    /// @param v GgVector 型のベクトル.
    /// @return オブジェクトと v のそれぞれの 4 要素の内積.
    ///
    GLfloat dot4(const GgVector& v) const
    {
      return ggDot4(data(), v.data());
    }

    ///
    /// GgVector 型の 4 要素の長さ.
    ///
    /// @return オブジェクトの 4 要素の長さ.
    ///
    GLfloat length4() const
    {
      return ggLength4(data());
    }

    ///
    /// GgVector 型の 4 要素の距離.
    ///
    /// @param v GgVector 型のベクトル.
    /// @return オブジェクトと v の 4 要素の距離.
    ///
    GLfloat distance4(const GgVector& v) const
    {
      return ggDistance4(data(), v.data());
    }

    ///
    /// GgVector 型の 4 要素の正規化.
    ///
    /// @return GLfloat 型の 4 要素の配列変数.
    ///
    GgVector normalize4() const
    {
      GgVector b;
      ggNormalize4(data(), b.data());
      return b;
    }
  };

  ///
  /// 何もしない.
  ///
  /// @param v GgVector 型のベクトル.
  /// @return v の値.
  ///
  inline const GgVector& operator+(const GgVector& v)
  {
    return v;
  }

  ///
  /// スカラーに GgVector 型の各要素を足した和を返す.
  ///
  /// @param a GLfloat 型の値.
  /// @param b GgVector 型のベクトル.
  /// @return a に b の各要素を足した和.
  ///
  inline GgVector operator+(GLfloat a, const GgVector& b)
  {
    return GgVector{ a + b[0], a + b[1], a + b[2], a + b[3] };
  }

  ///
  /// 符号の反転.
  ///
  /// @param v GgVector 型のベクトル.
  /// @return v の値の符号を反転した結果.
  ///
  inline const GgVector operator-(const GgVector& v)
  {
    return GgVector{ -v[0], -v[1], -v[2], -v[3] };
  }

  ///
  /// スカラーから GgVector 型の各要素を引いた差を返す.
  ///
  /// @param a GLfloat 型の値.
  /// @param b GgVector 型のベクトル.
  /// @return a から b の各要素を引いた差.
  ///
  inline GgVector operator-(GLfloat a, const GgVector& b)
  {
    return GgVector{ a - b[0], a - b[1], a - b[2], a - b[3] };
  }

  ///
  /// スカラーに GgVector 型の各要素を乗じた積を返す.
  ///
  /// @param a GLfloat 型の値.
  /// @param b GgVector 型のベクトル.
  /// @return a に b の各要素を乗じた積.
  ///
  inline GgVector operator*(GLfloat a, const GgVector& b)
  {
    return GgVector{ a * b[0], a * b[1], a * b[2], a * b[3] };
  }

  ///
  /// スカラーを GgVector 型の各要素で割った商を返す.
  ///
  /// @param a GLfloat 型の値.
  /// @param b GgVector 型のベクトル.
  /// @return a を b の各要素で割った商.
  ///
  inline GgVector operator/(GLfloat a, const GgVector& b)
  {
    return GgVector{ a / b[0], a / b[1], a / b[2], a / b[3] };
  }

  ///
  /// GgVector 型の 3 要素の外積.
  ///
  /// @param a GgVector 型のベクトル.
  /// @param b GgVector 型のベクトル.
  /// @return a と b の外積.
  ///
  /// @note
  /// 戻り値の w (第4) 要素は 0.
  ///
  inline GgVector ggCross(const GgVector& a, const GgVector& b)
  {
    GgVector c;
    ggCross(c.data(), a.data(), b.data());
    return c;
  }

  ///
  /// GgVector 型の 3 要素の内積.
  ///
  /// @param a GgVector 型のベクトル.
  /// @param b GgVector 型のベクトル.
  /// @return a と b のそれぞれの 3 要素の内積.
  ///
  inline GLfloat ggDot3(const GgVector& a, const GgVector& b)
  {
    return ggDot3(a.data(), b.data());;
  }

  ///
  /// GgVector 型の 3 要素の長さ.
  ///
  /// @param a GgVector 型のベクトル.
  /// @return a の 3 要素の長さ.
  ///
  inline GLfloat ggLength3(const GgVector& a)
  {
    return ggLength3(a.data());
  }

  ///
  /// GgVector 型の 3 要素の距離.
  ///
  /// @param a GgVector 型のベクトル.
  /// @param b GgVector 型のベクトル.
  /// @return a と b の距離.
  ///
  inline GLfloat ggDistance3(const GgVector& a, const GgVector& b)
  {
    return ggDistance3(a.data(), b.data());
  }

  ///
  /// GgVector 型の 3 要素の正規化.
  ///
  /// @param a GgVector 型のベクトル.
  /// @return a の 3 要素を正規化したもの.
  ///
  /// @note
  /// 戻り値の w (第4) 要素は 0 になる.
  ///
  inline GgVector ggNormalize3(const GgVector& a)
  {
    GgVector b;
    ggNormalize3(a.data(), b.data());
    b.data()[3] = 0.0f;
    return b;
  }

  ///
  /// GgVector 型の 3 要素の正規化.
  ///
  /// @param a GgVector 型の変数のポインタ.
  ///
  /// @note
  /// a の w (第4) 要素は 0 になる.
  ///
  inline void ggNormalize3(GgVector* a)
  {
    ggNormalize3(a->data());
    a->data()[3] = 0.0f;
  }

  ///
  /// GgVector 型の 4 要素の内積.
  ///
  /// @param a GgVector 型の変数.
  /// @param b GgVector 型の変数.
  /// @return a と b のそれぞれの 4 要素の内積.
  ///
  inline GLfloat ggDot4(const GgVector& a, const GgVector& b)
  {
    return ggDot4(a.data(), b.data());
  }

  ///
  /// GgVector 型の 4 要素の長さ.
  ///
  /// @param a GgVector 型の変数.
  /// @return a の 4 要素の長さ.
  ///
  inline GLfloat ggLength4(const GgVector& a)
  {
    return ggLength4(a.data());
  }

  ///
  /// GgVector 型の 4 要素の距離.
  ///
  /// @param a GgVector 型の変数.
  /// @param b GgVector 型の変数.
  /// @return 2 つの GgVector a, b の距離.
  ///
  inline GLfloat ggDistance4(const GgVector& a, const GgVector& b)
  {
    return ggDistance4(a.data(), b.data());
  }

  ///
  /// GgVector 型の 4 要素の正規化.
  ///
  /// @param a GgVector 型の変数.
  /// @return a の 4 要素を正規化した結果.
  ///
  inline GgVector ggNormalize4(const GgVector& a)
  {
    GgVector b;
    ggNormalize4(a.data(), b.data());
    return b;
  }

  ///
  /// GgVector 型の 4 要素の正規化.
  ///
  /// @param a GLfloat 型の 4 要素の配列変数.
  ///
  inline void ggNormalize4(GgVector* a)
  {
    ggNormalize4(a->data());
  }

  ///
  /// 変換行列.
  ///
  class GgMatrix : public std::array<GLfloat, 16>
  {
    // 行列 a とベクトル b の積をベクトル c に代入する
    void projection(GLfloat* c, const GLfloat* a, const GLfloat* b) const;

    // 行列 a と行列 b の積を行列 c に代入する
    void multiply(GLfloat* c, const GLfloat* a, const GLfloat* b) const;

  public:

    ///
    /// コンストラクタ.
    ///
    GgMatrix()
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param m00 GLfloat 型の値.
    /// @param m01 GLfloat 型の値.
    /// @param m02 GLfloat 型の値.
    /// @param m03 GLfloat 型の値.
    /// @param m10 GLfloat 型の値.
    /// @param m11 GLfloat 型の値.
    /// @param m12 GLfloat 型の値.
    /// @param m13 GLfloat 型の値.
    /// @param m20 GLfloat 型の値.
    /// @param m21 GLfloat 型の値.
    /// @param m22 GLfloat 型の値.
    /// @param m23 GLfloat 型の値.
    /// @param m30 GLfloat 型の値.
    /// @param m31 GLfloat 型の値.
    /// @param m32 GLfloat 型の値.
    /// @param m33 GLfloat 型の値.
    ///
    constexpr GgMatrix(
      GLfloat m00, GLfloat m01, GLfloat m02, GLfloat m03,
      GLfloat m10, GLfloat m11, GLfloat m12, GLfloat m13,
      GLfloat m20, GLfloat m21, GLfloat m22, GLfloat m23,
      GLfloat m30, GLfloat m31, GLfloat m32, GLfloat m33
    ) :
      std::array<GLfloat, 16>{ m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33 }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param c GLfloat 型の値.
    ///
    constexpr GgMatrix(GLfloat c) :
      GgMatrix{ c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param a GLfloat 型の 16 要素の配列変数.
    ///
    GgMatrix(const GLfloat* a)
    {
      operator=(a);
    }

    ///
    /// 配列変数の値を格納する.
    ///
    /// @param a GLfloat 型の 16 要素の配列変数.
    /// @return a を代入したこのオブジェクトの参照.
    ///
    GgMatrix& operator=(const GLfloat* a)
    {
      std::copy(a, a + size(), data());
      return *this;
    }

    ///
    /// 変換行列に配列に格納した変換行列を加算した値を返す.
    ///
    /// @param a 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    /// @return 変換行列に a を加えた GgMatrix 型の変換行列.
    ///
    GgMatrix operator+(const GLfloat* a) const
    {
      GgMatrix t;
      for (std::size_t i = 0; i < size(); ++i) t[i] = data()[i] + a[i];
      return t;
    }

    ///
    /// 変換行列に別の変換行列を加算した値を返す.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return 変換行列に a を加えた GgMatrix 型の変換行列.
    ///
    GgMatrix operator+(const GgMatrix& m) const
    {
      return operator+(m.data());
    }

    ///
    /// 変換行列に配列に格納した変換行列を加算した結果を格納する.
    ///
    /// @param a 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    /// @return a を加えた変換行列の参照.
    ///
    GgMatrix& operator+=(const GLfloat* a)
    {
      for (std::size_t i = 0; i < size(); ++i) data()[i] += a[i];
      return *this;
    }

    ///
    /// 変換行列に別の変換行列を加算した結果を格納する.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return m を加えた変換行列の参照.
    ///
    GgMatrix& operator+=(const GgMatrix& m)
    {
      return operator+=(m.data());
    }

    ///
    /// 変換行列から配列に格納した変換行列を減算した結果を格納する.
    ///
    /// @param a 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    /// @return 変換行列から a を引いた GgMatrix 型の変換行列.
    ///
    GgMatrix operator-(const GLfloat* a) const
    {
      GgMatrix t;
      for (std::size_t i = 0; i < size(); ++i) t[i] = data()[i] - a[i];
      return t;
    }

    ///
    /// 変換行列から別の変換行列を減算した値を返す.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return 変換行列から m を引いた GgMatrix 型の変換行列.
    ///
    GgMatrix operator-(const GgMatrix& m) const
    {
      return operator-(m.data());
    }

    ///
    /// 変換行列に配列に格納した変換行列を減算した結果を格納する.
    ///
    /// @param a 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    /// @return a を引いた変換行列の参照.
    ///
    GgMatrix& operator-=(const GLfloat* a)
    {
      for (std::size_t i = 0; i < size(); ++i) data()[i] -= a[i];
      return *this;
    }

    ///
    /// 変換行列に別の変換行列を減算した結果を格納する.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return m を引いた変換行列の参照.
    ///
    GgMatrix& operator-=(const GgMatrix& m)
    {
      return operator-=(m.data());
    }

    ///
    /// 変換行列に配列に格納した変換行列を乗算した値を返す.
    ///
    /// @param a 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    /// @return 変換行列に a を乗じた GgMatrix 型の変換行列.
    ///
    GgMatrix operator*(const GLfloat* a) const
    {
      GgMatrix t;
      multiply(t.data(), data(), a);
      return t;
    }

    ///
    /// 変換行列に別の変換行列を乗算した値を返す.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return 変換行列に a を乗じた GgMatrix 型の変換行列.
    ///
    GgMatrix operator*(const GgMatrix& m) const
    {
      return operator*(m.data());
    }

    ///
    /// 変換行列に配列に格納した変換行列を乗算した結果を格納する.
    ///
    /// @param a 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    /// @return a を掛けた変換行列の参照.
    ///
    GgMatrix& operator*=(const GLfloat* a)
    {
      *this = operator*(a);
      return *this;
    }

    ///
    /// 変換行列に別の変換行列を乗算した結果を格納する.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return m を掛けた変換行列の参照.
    ///
    GgMatrix& operator*=(const GgMatrix& m)
    {
      return operator*=(m.data());
    }

    ///
    /// 変換行列を配列に格納した変換行列で除算した値を返す.
    ///
    /// @param a 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    /// @return 変換行列を a で割った GgMatrix 型の変換行列.
    ///
    GgMatrix operator/(const GLfloat* a) const
    {
      GgMatrix i, t;
      i.loadInvert(a);
      multiply(t.data(), data(), i.data());
      return t;
    }

    ///
    /// 変換行列を変換行列で除算した値を返す.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return 変換行列を a で割った GgMatrix 型の変換行列.
    ///
    GgMatrix operator/(const GgMatrix& m) const
    {
      return operator/(m.data());
    }

    ///
    /// 変換行列を配列に格納した変換行列で除算した結果を格納する.
    ///
    /// @param a 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    /// @return a で割った変換行列の参照.
    ///
    GgMatrix& operator/=(const GLfloat* a)
    {
      *this = operator/(a);
      return *this;
    }

    ///
    /// 変換行列を別の変換行列で除算した結果を格納する.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return m で割った変換行列の参照.
    ///
    GgMatrix& operator/=(const GgMatrix& m)
    {
      return operator/=(m.data());
    }

    ///
    /// 単位行列を格納する.
    ///
    GgMatrix& loadIdentity();

    ///
    /// 平行移動の変換行列を格納する.
    ///
    /// @param x x 方向の移動量.
    /// @param y y 方向の移動量.
    /// @param z z 方向の移動量.
    /// @param w w 移動量のスケールファクタ (= 1.0f).
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadTranslate(GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0f);

    ///
    /// 平行移動の変換行列を格納する.
    ///
    /// @param t 移動量の GLfloat 型の配列 (x, y, z).
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadTranslate(const GLfloat* t)
    {
      return loadTranslate(t[0], t[1], t[2]);
    }

    ///
    /// 平行移動の変換行列を格納する.
    ///
    /// @param t 移動量の GgVector 型の変数.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadTranslate(const GgVector& t)
    {
      return loadTranslate(t[0], t[1], t[2], t[3]);
    }

    ///
    /// 拡大縮小の変換行列を格納する.
    ///
    /// @param x x 方向の拡大率.
    /// @param y y 方向の拡大率.
    /// @param z z 方向の拡大率.
    /// @param w w 拡大率のスケールファクタ (= 1.0f).
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadScale(GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0f);

    ///
    /// 拡大縮小の変換行列を格納する.
    ///
    /// @param s 拡大率の GLfloat 型の配列 (x, y, z).
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadScale(const GLfloat* s)
    {
      return loadScale(s[0], s[1], s[2]);
    }

    ///
    /// 拡大縮小の変換行列を格納する.
    ///
    /// @param s 拡大率の GgVector 型の変数.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadScale(const GgVector& s)
    {
      return loadScale(s[0], s[1], s[2], s[3]);
    }

    ///
    /// x 軸中心の回転の変換行列を格納する.
    ///
    /// @param a 回転角.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadRotateX(GLfloat a);

    ///
    /// y 軸中心の回転の変換行列を格納する.
    ///
    /// @param a 回転角.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadRotateY(GLfloat a);

    ///
    /// z 軸中心の回転の変換行列を格納する.
    ///
    /// @param a 回転角.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadRotateZ(GLfloat a);

    ///
    /// (x, y, z) 方向のベクトルを軸とする回転の変換行列を格納する.
    ///
    /// @param x 回転軸の x 成分.
    /// @param y 回転軸の y 成分.
    /// @param z 回転軸の z 成分.
    /// @param a 回転角.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadRotate(GLfloat x, GLfloat y, GLfloat z, GLfloat a);

    ///
    /// r 方向のベクトルを軸とする回転の変換行列を格納する.
    ///
    /// @param r 回転軸の方向ベクトルを格納した GLfloat 型の 3 要素の配列変数 (x, y, z).
    /// @param a 回転角.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadRotate(const GLfloat* r, GLfloat a)
    {
      return loadRotate(r[0], r[1], r[2], a);
    }

    ///
    /// r 方向のベクトルを軸とする回転の変換行列を格納する.
    ///
    /// @param r 回転軸の方向ベクトルを格納した GgVector 型のベクトル, 第 4 要素は無視する.
    /// @param a 回転角.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadRotate(const GgVector& r, GLfloat a)
    {
      return loadRotate(r[0], r[1], r[2], a);
    }

    ///
    /// r 方向のベクトルを軸とする回転の変換行列を格納する.
    ///
    /// @param r 回転軸の方向ベクトルと回転角を格納した GLfloat 型の 4 要素の配列変数, 第 4 要素を回転角に用いる.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadRotate(const GLfloat* r)
    {
      return loadRotate(r[0], r[1], r[2], r[3]);
    }

    ///
    /// r 方向のベクトルを軸とする回転の変換行列を格納する.
    ///
    /// @param r 回転軸の方向ベクトルと回転角を格納した GgVector 型のベクトル, 第 4 要素を回転角に用いる.
    /// @return 設定した変換行列.
    ///
    GgMatrix& loadRotate(const GgVector& r)
    {
      return loadRotate(r[0], r[1], r[2], r[3]);
    }

    ///
    /// ビュー変換行列を格納する.
    ///
    /// @param ex 視点の位置の x 座標値.
    /// @param ey 視点の位置の y 座標値.
    /// @param ez 視点の位置の z 座標値.
    /// @param tx 目標点の位置の x 座標値.
    /// @param ty 目標点の位置の y 座標値.
    /// @param tz 目標点の位置の z 座標値.
    /// @param ux 上方向のベクトルの x 成分.
    /// @param uy 上方向のベクトルの y 成分.
    /// @param uz 上方向のベクトルの z 成分.
    /// @return 設定したビュー変換行列.
    ///
    GgMatrix& loadLookat(GLfloat ex, GLfloat ey, GLfloat ez,
      GLfloat tx, GLfloat ty, GLfloat tz,
      GLfloat ux, GLfloat uy, GLfloat uz);

    ///
    /// ビュー変換行列を格納する.
    ///
    /// @param e 視点の位置の配列変数.
    /// @param t 目標点の位置の配列変数.
    /// @param u 上方向のベクトルの配列変数.
    /// @return 設定したビュー変換行列.
    ///
    GgMatrix& loadLookat(const GLfloat* e, const GLfloat* t, const GLfloat* u)
    {
      return loadLookat(e[0], e[1], e[2], t[0], t[1], t[2], u[0], u[1], u[2]);
    }

    ///
    /// ビュー変換行列を格納する.
    ///
    /// @param e 視点の位置の GgVector 型の変数.
    /// @param t 目標点の位置の GgVector 型の変数.
    /// @param u 上方向のベクトルの GgVector 型の変数.
    /// @return 設定したビュー変換行列.
    ///
    GgMatrix& loadLookat(const GgVector& e, const GgVector& t, const GgVector& u)
    {
      return loadLookat(e[0], e[1], e[2], t[0], t[1], t[2], u[0], u[1], u[2]);
    }

    ///
    /// 直交投影変換行列を格納する.
    ///
    /// @param left ウィンドウの左端の位置.
    /// @param right ウィンドウの右端の位置.
    /// @param bottom ウィンドウの下端の位置.
    /// @param top ウィンドウの上端の位置.
    /// @param zNear 視点から前方面までの位置.
    /// @param zFar 視点から後方面までの位置.
    /// @return 設定した直交投影変換行列.
    ///
    GgMatrix& loadOrthogonal(GLfloat left, GLfloat right,
      GLfloat bottom, GLfloat top,
      GLfloat zNear, GLfloat zFar);

    ///
    /// 透視透視投影変換行列を格納する.
    ///
    /// @param left ウィンドウの左端の位置.
    /// @param right ウィンドウの右端の位置.
    /// @param bottom ウィンドウの下端の位置.
    /// @param top ウィンドウの上端の位置.
    /// @param zNear 視点から前方面までの位置.
    /// @param zFar 視点から後方面までの位置.
    /// @return 設定した透視投影変換行列.
    ///
    GgMatrix& loadFrustum(GLfloat left, GLfloat right,
      GLfloat bottom, GLfloat top,
      GLfloat zNear, GLfloat zFar);

    ///
    /// 画角を指定して透視投影変換行列を格納する.
    ///
    /// @param fovy y 方向の画角.
    /// @param aspect 縦横比.
    /// @param zNear 視点から前方面までの位置.
    /// @param zFar 視点から後方面までの位置.
    /// @return 設定した透視投影変換行列.
    ///
    GgMatrix& loadPerspective(GLfloat fovy, GLfloat aspect,
      GLfloat zNear, GLfloat zFar);

    ///
    /// 転置行列を格納する.
    ///
    /// @param a GLfloat 型の 16 要素の変換行列.
    /// @return 設定した a の転置行列.
    ///
    GgMatrix& loadTranspose(const GLfloat* a);

    ///
    /// 転置行列を格納する.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return 設定した m の転置行列.
    ///
    GgMatrix& loadTranspose(const GgMatrix& m)
    {
      return loadTranspose(m.data());
    }

    ///
    /// 逆行列を格納する.
    ///
    /// @param a GLfloat 型の 16 要素の変換行列.
    /// @return 設定した a の逆行列.
    ///
    GgMatrix& loadInvert(const GLfloat* a);

    ///
    /// 逆行列を格納する.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return 設定した m の逆行列.
    ///
    GgMatrix& loadInvert(const GgMatrix& m)
    {
      return loadInvert(m.data());
    }

    ///
    /// 法線変換行列を格納する.
    ///
    /// @param a GLfloat 型の 16 要素の変換行列.
    /// @return 設定した m の法線変換行列.
    ///
    GgMatrix& loadNormal(const GLfloat* a);

    ///
    /// 法線変換行列を格納する.
    ///
    /// @param m GgMatrix 型の変換行列.
    /// @return 設定した m の法線変換行列.
    ///
    GgMatrix& loadNormal(const GgMatrix& m)
    {
      return loadNormal(m.data());
    }

    ///
    /// 平行移動変換を乗じた結果を返す.
    ///
    /// @param x x 方向の移動量.
    /// @param y y 方向の移動量.
    /// @param z z 方向の移動量.
    /// @param w w 移動量のスケールファクタ (= 1.0f).
    /// @return 平行移動した結果の変換行列.
    ///
    GgMatrix translate(GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0f) const
    {
      GgMatrix m;
      return operator*(m.loadTranslate(x, y, z, w));
    }

    ///
    /// 平行移動変換を乗じた結果を返す.
    ///
    /// @param t 移動量の GLfloat 型の 3 要素の配列変数 (x, y, z).
    /// @return 平行移動した結果の変換行列.
    ///
    GgMatrix translate(const GLfloat* t) const
    {
      return translate(t[0], t[1], t[2]);
    }

    ///
    /// 平行移動変換を乗じた結果を返す.
    ///
    /// @param t 移動量の GgVector 型の変数.
    /// @return 平行移動した結果の変換行列.
    ///
    GgMatrix translate(const GgVector& t) const
    {
      return translate(t[0], t[1], t[2], t[3]);
    }

    ///
    /// 拡大縮小変換を乗じた結果を返す.
    ///
    /// @param x x 方向の拡大率.
    /// @param y y 方向の拡大率.
    /// @param z z 方向の拡大率.
    /// @param w w 移動量のスケールファクタ (= 1.0f).
    /// @return 拡大縮小した結果の変換行列.
    ///
    GgMatrix scale(GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0f) const
    {
      GgMatrix m;
      return operator*(m.loadScale(x, y, z, w));
    }

    ///
    /// 拡大縮小変換を乗じた結果を返す.
    ///
    /// @param s 拡大率の GLfloat 型の 3 要素の配列変数 (x, y, z).
    /// @return 拡大縮小した結果の変換行列.
    ///
    GgMatrix scale(const GLfloat* s) const
    {
      return scale(s[0], s[1], s[2]);
    }

    ///
    /// 拡大縮小変換を乗じた結果を返す.
    ///
    /// @param s 拡大率の GgVector 型の変数.
    /// @return 拡大縮小した結果の変換行列.
    ///
    GgMatrix scale(const GgVector& s) const
    {
      return scale(s[0], s[1], s[2], s[3]);
    }

    ///
    /// x 軸中心の回転変換を乗じた結果を返す.
    ///
    /// @param a 回転角.
    /// @return x 軸中心にさらに a 回転した変換行列.
    ///
    GgMatrix rotateX(GLfloat a) const
    {
      GgMatrix m;
      return operator*(m.loadRotateX(a));
    }

    ///
    /// y 軸中心の回転変換を乗じた結果を返す.
    ///
    /// @param a 回転角.
    /// @return y 軸中心にさらに a 回転した変換行列.
    ///
    GgMatrix rotateY(GLfloat a) const
    {
      GgMatrix m;
      return operator*(m.loadRotateY(a));
    }

    ///
    /// z 軸中心の回転変換を乗じた結果を返す.
    ///
    /// @param a 回転角.
    /// @return z 軸中心にさらに a 回転した変換行列.
    ///
    GgMatrix rotateZ(GLfloat a) const
    {
      GgMatrix m;
      return operator*(m.loadRotateZ(a));
    }

    ///
    /// (x, y, z) 方向のベクトルを軸とする回転変換を乗じた結果を返す.
    ///
    /// @param x 回転軸の x 成分.
    /// @param y 回転軸の y 成分.
    /// @param z 回転軸の z 成分.
    /// @param a 回転角.
    /// @return (x, y, z) を軸にさらに a 回転した変換行列.
    ///
    GgMatrix rotate(GLfloat x, GLfloat y, GLfloat z, GLfloat a) const
    {
      GgMatrix m;
      return operator*(m.loadRotate(x, y, z, a));
    }

    ///
    /// r 方向のベクトルを軸とする回転変換を乗じた結果を返す.
    ///
    /// @param r 回転軸の方向ベクトルを格納した GLfloat 型の 3 要素の配列変数 (x, y, z).
    /// @param a 回転角.
    /// @return (r[0], r[1], r[2]) を軸にさらに a 回転した変換行列.
    ///
    GgMatrix rotate(const GLfloat* r, GLfloat a) const
    {
      return rotate(r[0], r[1], r[2], a);
    }

    ///
    /// r 方向のベクトルを軸とする回転変換を乗じた結果を返す.
    ///
    /// @param r 回転軸の方向ベクトルを格納した GgVector 型の変数.
    /// @param a 回転角.
    /// @return (r[0], r[1], r[2]) を軸にさらに a 回転した変換行列.
    ///
    GgMatrix rotate(const GgVector& r, GLfloat a) const
    {
      return rotate(r[0], r[1], r[2], a);
    }

    ///
    /// r 方向のベクトルを軸とする回転の変換行列を乗じた結果を返す.
    ///
    /// @param r 回転軸の方向ベクトルと回転角を格納した GLfloat 型の 4 要素の配列変数 (x, y, z, a).
    /// @return (r[0], r[1], r[2]) を軸にさらに r[3] 回転した変換行列.
    ///
    GgMatrix rotate(const GLfloat* r) const
    {
      return rotate(r[0], r[1], r[2], r[3]);
    }

    ///
    /// r 方向のベクトルを軸とする回転の変換行列を乗じた結果を返す.
    ///
    /// @param r 回転軸の方向ベクトルと回転角を格納した GgVector 型の変数).
    /// @return (r[0], r[1], r[2]) を軸にさらに r[3] 回転した変換行列.
    ///
    GgMatrix rotate(const GgVector& r) const
    {
      return rotate(r[0], r[1], r[2], r[3]);
    }

    ///
    /// ビュー変換を乗じた結果を返す.
    ///
    /// @param ex 視点の位置の x 座標値.
    /// @param ey 視点の位置の y 座標値.
    /// @param ez 視点の位置の z 座標値.
    /// @param tx 目標点の位置の x 座標値.
    /// @param ty 目標点の位置の y 座標値.
    /// @param tz 目標点の位置の z 座標値.
    /// @param ux 上方向のベクトルの x 成分.
    /// @param uy 上方向のベクトルの y 成分.
    /// @param uz 上方向のベクトルの z 成分.
    /// @return ビュー変換行列を乗じた変換行列.
    ///
    GgMatrix lookat(
      GLfloat ex, GLfloat ey, GLfloat ez,
      GLfloat tx, GLfloat ty, GLfloat tz,
      GLfloat ux, GLfloat uy, GLfloat uz
    ) const
    {
      GgMatrix m;
      return operator*(m.loadLookat(ex, ey, ez, tx, ty, tz, ux, uy, uz));
    }

    ///
    /// ビュー変換を乗じた結果を返す.
    ///
    /// @param e 視点の位置を格納した GLfloat 型の 3 要素の配列変数.
    /// @param t 目標点の位置を格納した GLfloat 型の 3 要素の配列変数.
    /// @param u 上方向のベクトルを格納した GLfloat 型の 3 要素の配列変数.
    /// @return ビュー変換行列を乗じた変換行列.
    ///
    GgMatrix lookat(const GLfloat* e, const GLfloat* t, const GLfloat* u) const
    {
      return lookat(e[0], e[1], e[2], t[0], t[1], t[2], u[0], u[1], u[2]);
    }

    ///
    /// ビュー変換を乗じた結果を返す.
    ///
    /// @param e 視点の位置を格納した GgVector 型の変数.
    /// @param t 目標点の位置を格納した GgVector 型の変数.
    /// @param u 上方向のベクトルを格納した GgVector 型の変数.
    /// @return ビュー変換行列を乗じた変換行列.
    ///
    GgMatrix lookat(const GgVector& e, const GgVector& t, const GgVector& u) const
    {
      return lookat(e[0], e[1], e[2], t[0], t[1], t[2], u[0], u[1], u[2]);
    }

    ///
    /// 直交投影変換を乗じた結果を返す.
    ///
    /// @param left ウィンドウの左端の位置.
    /// @param right ウィンドウの右端の位置.
    /// @param bottom ウィンドウの下端の位置.
    /// @param top ウィンドウの上端の位置.
    /// @param zNear 視点から前方面までの位置.
    /// @param zFar 視点から後方面までの位置.
    /// @return 直交投影変換行列を乗じた変換行列.
    ///
    GgMatrix orthogonal(
      GLfloat left, GLfloat right,
      GLfloat bottom, GLfloat top,
      GLfloat zNear, GLfloat zFar
    ) const
    {
      GgMatrix m;
      return operator*(m.loadOrthogonal(left, right, bottom, top, zNear, zFar));
    }

    ///
    /// 透視投影変換を乗じた結果を返す.
    ///
    /// @param left ウィンドウの左端の位置.
    /// @param right ウィンドウの右端の位置.
    /// @param bottom ウィンドウの下端の位置.
    /// @param top ウィンドウの上端の位置.
    /// @param zNear 視点から前方面までの位置.
    /// @param zFar 視点から後方面までの位置.
    /// @return 透視投影変換行列を乗じた変換行列.
    ///
    GgMatrix frustum(
      GLfloat left, GLfloat right,
      GLfloat bottom, GLfloat top,
      GLfloat zNear, GLfloat zFar
    ) const
    {
      GgMatrix m;
      return operator*(m.loadFrustum(left, right, bottom, top, zNear, zFar));
    }

    ///
    /// 画角を指定して透視投影変換を乗じた結果を返す.
    ///
    /// @param fovy y 方向の画角.
    /// @param aspect 縦横比.
    /// @param zNear 視点から前方面までの位置.
    /// @param zFar 視点から後方面までの位置.
    /// @return 透視投影変換行列を乗じた変換行列.
    ///
    GgMatrix perspective(
      GLfloat fovy, GLfloat aspect,
      GLfloat zNear, GLfloat zFar
    ) const
    {
      GgMatrix m;
      return operator*(m.loadPerspective(fovy, aspect, zNear, zFar));
    }

    ///
    /// 転置行列を返す.
    ///
    /// @return 転置行列.
    ///
    GgMatrix transpose() const
    {
      GgMatrix t;
      return t.loadTranspose(*this);
    }

    ///
    /// 逆行列を返す.
    ///
    /// @return 逆行列.
    ///
    GgMatrix invert() const
    {
      GgMatrix t;
      return t.loadInvert(*this);
    }

    ///
    /// 法線変換行列を返す.
    ///
    /// @return 法線変換行列.
    ///
    GgMatrix normal() const
    {
      GgMatrix t;
      return t.loadNormal(*this);
    }

    ///
    /// ベクトルに対して投影変換を行う.
    ///
    /// @param c 変換結果を格納する GLfloat 型の 4 要素の配列変数.
    /// @param v 元のベクトルの GLfloat 型の 4 要素の配列変数.
    ///
    void projection(GLfloat* c, const GLfloat* v) const
    {
      projection(c, data(), v);
    }

    ///
    /// ベクトルに対して投影変換を行う.
    ///
    /// @param c 変換結果を格納する GLfloat 型の 4 要素の配列変数.
    /// @param v 元のベクトルの GgVector 型の変数.
    ///
    void projection(GLfloat* c, const GgVector& v) const
    {
      projection(c, v.data());
    }

    ///
    /// ベクトルに対して投影変換を行う.
    ///
    /// @param c 変換結果を格納する GgVector 型の変数.
    /// @param v 元のベクトルの GLfloat 型の 4 要素の配列変数.
    ///
    void projection(GgVector& c, const GLfloat* v) const
    {
      projection(c.data(), v);
    }

    ///
    /// ベクトルに対して投影変換を行う.
    ///
    /// @param c 変換結果を格納する GgVector 型の変数.
    /// @param v 元のベクトルの GgVector 型の変数.
    ///
    void projection(GgVector& c, const GgVector& v) const
    {
      projection(c.data(), v.data());
    }

    ///
    /// ベクトルに対して投影変換を行う.
    ///
    /// @param v 元のベクトルの GgVector 型の変数.
    /// @return v 変換結果の GgVector 型のベクトル.
    ///
    GgVector operator*(const GgVector& v) const
    {
      GgVector c;
      projection(c, v);
      return c;
    }

    ///
    /// 変換行列を取り出す.
    ///
    /// @return 変換行列を格納した GLfloat 型の 16 要素の配列変数.
    ///
    const GLfloat* get() const
    {
      return data();
    }

    ///
    /// 変換行列を取り出す.
    ///
    /// @param a 変換行列を格納する GLfloat 型の 16 要素の配列変数.
    ///
    void get(GLfloat* a) const
    {
      std::copy(data(), data() + size(), a);
    }
  };

  ///
  /// 単位行列を返す.
  ///
  /// @return 単位行列.
  ///
  inline GgMatrix ggIdentity()
  {
    GgMatrix t;
    return t.loadIdentity();
  };

  ///
  /// 平行移動の変換行列を返す.
  ///
  /// @param x x 方向の移動量.
  /// @param y y 方向の移動量.
  /// @param z z 方向の移動量.
  /// @param w 移動量のスケールファクタ (= 1.0f).
  /// @return 平行移動の変換行列.
  ///
  inline GgMatrix ggTranslate(GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0f)
  {
    GgMatrix m;
    return m.loadTranslate(x, y, z, w);
  }

  ///
  /// 平行移動の変換行列を返す.
  ///
  /// @param t 移動量の GLfloat 型の 3 要素の配列変数 (x, y, z).
  /// @return 平行移動の変換行列.
  ///
  inline GgMatrix ggTranslate(const GLfloat* t)
  {
    GgMatrix m;
    return m.loadTranslate(t[0], t[1], t[2]);
  }

  ///
  /// 平行移動の変換行列を返す.
  ///
  /// @param t 移動量の GgVector 型の変数.
  /// @return 平行移動の変換行列.
  ///
  inline GgMatrix ggTranslate(const GgVector& t)
  {
    GgMatrix m;
    return m.loadTranslate(t[0], t[1], t[2], t[3]);
  }

  ///
  /// 拡大縮小の変換行列を返す.
  ///
  /// @param x x 方向の拡大率.
  /// @param y y 方向の拡大率.
  /// @param z z 方向の拡大率.
  /// @param w 拡大率のスケールファクタ (= 1.0f).
  /// @return 拡大縮小の変換行列.
  ///
  inline GgMatrix ggScale(GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0f)
  {
    GgMatrix m;
    return m.loadScale(x, y, z, w);
  }

  ///
  /// 拡大縮小の変換行列を返す.
  ///
  /// @param s 拡大率の GLfloat 型の 3 要素の配列変数 (x, y, z).
  /// @return 拡大縮小の変換行列.
  ///
  inline GgMatrix ggScale(const GLfloat* s)
  {
    GgMatrix m;
    return m.loadScale(s[0], s[1], s[2]);
  }

  ///
  /// 拡大縮小の変換行列を返す.
  ///
  /// @param s 拡大率の GgVector 型の変数.
  /// @return 拡大縮小の変換行列.
  ///
  inline GgMatrix ggScale(const GgVector& s)
  {
    GgMatrix m;
    return m.loadScale(s[0], s[1], s[2], s[3]);
  }

  ///
  /// x 軸中心の回転の変換行列を返す.
  ///
  /// @param a 回転角.
  /// @return x 軸中心に a だけ回転する変換行列.
  ///
  inline GgMatrix ggRotateX(GLfloat a)
  {
    GgMatrix m;
    return m.loadRotateX(a);
  }

  ///
  /// y 軸中心の回転の変換行列を返す.
  ///
  /// @param a 回転角.
  /// @return y 軸中心に a だけ回転する変換行列.
  ///
  inline GgMatrix ggRotateY(GLfloat a)
  {
    GgMatrix m;
    return m.loadRotateY(a);
  }

  ///
  /// z 軸中心の回転の変換行列を返す.
  ///
  /// @param a 回転角.
  /// @return z 軸中心に a だけ回転する変換行列.
  ///
  inline GgMatrix ggRotateZ(GLfloat a)
  {
    GgMatrix m;
    return m.loadRotateZ(a);
  }

  ///
  /// (x, y, z) 方向のベクトルを軸とする回転の変換行列を乗じた結果を返す.
  ///
  /// @param x 回転軸の x 成分.
  /// @param y 回転軸の y 成分.
  /// @param z 回転軸の z 成分.
  /// @param a 回転角.
  /// @return (x, y, z) を軸にさらに a 回転する変換行列.
  ///
  inline GgMatrix ggRotate(GLfloat x, GLfloat y, GLfloat z, GLfloat a)
  {
    GgMatrix m;
    return m.loadRotate(x, y, z, a);
  }

  ///
  /// r 方向のベクトルを軸とする回転の変換行列を乗じた結果を返す.
  ///
  /// @param r 回転軸のベクトルを表す GLfloat 型の 3 要素の配列変数.
  /// @param a 回転角.
  /// @return r を軸に a だけ回転する変換行列.
  ///
  inline GgMatrix ggRotate(const GLfloat* r, GLfloat a)
  {
    GgMatrix m;
    return m.loadRotate(r[0], r[1], r[2], a);
  }

  ///
  /// r 方向のベクトルを軸とする回転の変換行列を乗じた結果を返す.
  ///
  /// @param r 回転軸のベクトルを表す GgVector 型の変数.
  /// @param a 回転角.
  /// @return r を軸に a だけ回転する変換行列.
  ///
  inline GgMatrix ggRotate(const GgVector& r, GLfloat a)
  {
    GgMatrix m;
    return m.loadRotate(r[0], r[1], r[2], a);
  }

  ///
  /// r 方向のベクトルを軸とする回転の変換行列を乗じた結果を返す.
  ///
  /// @param r 回転軸のベクトルと回転角を表す GLfloat 型の 4 要素の配列変数.
  /// @return (r[0], r[1], r[2]) を軸に r[3] だけ回転する変換行列.
  ///
  inline GgMatrix ggRotate(const GLfloat* r)
  {
    GgMatrix m;
    return m.loadRotate(r[0], r[1], r[2], r[3]);
  }

  ///
  /// r 方向のベクトルを軸とする回転の変換行列を乗じた結果を返す.
  ///
  /// @param r 回転軸のベクトルと回転角を表す GgVector 型の変数.
  /// @return (r[0], r[1], r[2]) を軸に r[3] だけ回転する変換行列.
  ///
  inline GgMatrix ggRotate(const GgVector& r)
  {
    GgMatrix m;
    return m.loadRotate(r[0], r[1], r[2], r[3]);
  }

  ///
  /// ビュー変換行列を返す.
  ///
  /// @param ex 視点の位置の x 座標値.
  /// @param ey 視点の位置の y 座標値.
  /// @param ez 視点の位置の z 座標値.
  /// @param tx 目標点の位置の x 座標値.
  /// @param ty 目標点の位置の y 座標値.
  /// @param tz 目標点の位置の z 座標値.
  /// @param ux 上方向のベクトルの x 成分.
  /// @param uy 上方向のベクトルの y 成分.
  /// @param uz 上方向のベクトルの z 成分.
  /// @return 求めたビュー変換行列.
  ///
  inline GgMatrix ggLookat(
    GLfloat ex, GLfloat ey, GLfloat ez,     // 視点の位置
    GLfloat tx, GLfloat ty, GLfloat tz,     // 目標点の位置
    GLfloat ux, GLfloat uy, GLfloat uz      // 上方向のベクトル
  )
  {
    GgMatrix m;
    return m.loadLookat(ex, ey, ez, tx, ty, tz, ux, uy, uz);
  }

  ///
  /// ビュー変換行列を返す.
  ///
  /// @param e 視点の位置を格納した GLfloat 型の 3 要素の配列変数.
  /// @param t 目標点の位置を格納した GLfloat 型の 3 要素の配列変数.
  /// @param u 上方向のベクトルを格納した GLfloat 型の 3 要素の配列変数.
  /// @return 求めたビュー変換行列.
  ///
  inline GgMatrix ggLookat(
    const GLfloat* e,                       // 視点の位置
    const GLfloat* t,                       // 目標点の位置
    const GLfloat* u                        // 上方向のベクトル
  )
  {
    GgMatrix m;
    return m.loadLookat(e[0], e[1], e[2], t[0], t[1], t[2], u[0], u[1], u[2]);
  }

  ///
  /// ビュー変換行列を返す.
  ///
  /// @param e 視点の位置を格納した GgVector 型の変数.
  /// @param t 目標点の位置を格納した GgVector 型の変数.
  /// @param u 上方向のベクトルを格納した GgVector 型の変数.
  /// @return 求めたビュー変換行列.
  ///
  inline GgMatrix ggLookat(
    const GgVector& e,                      // 視点の位置
    const GgVector& t,                      // 目標点の位置
    const GgVector& u                       // 上方向のベクトル
  )
  {
    GgMatrix m;
    return m.loadLookat(e[0], e[1], e[2], t[0], t[1], t[2], u[0], u[1], u[2]);
  }

  ///
  /// 直交投影変換行列を返す.
  ///
  /// @param left ウィンドウの左端の位置.
  /// @param right ウィンドウの右端の位置.
  /// @param bottom ウィンドウの下端の位置.
  /// @param top ウィンドウの上端の位置.
  /// @param zNear 視点から前方面までの位置.
  /// @param zFar 視点から後方面までの位置.
  /// @return 求めた直交投影変換行列.
  ///
  inline GgMatrix ggOrthogonal(GLfloat left, GLfloat right,
    GLfloat bottom, GLfloat top,
    GLfloat zNear, GLfloat zFar)
  {
    GgMatrix m;
    return m.loadOrthogonal(left, right, bottom, top, zNear, zFar);
  }

  ///
  /// 透視透視投影変換行列を返す.
  ///
  /// @param left ウィンドウの左端の位置.
  /// @param right ウィンドウの右端の位置.
  /// @param bottom ウィンドウの下端の位置.
  /// @param top ウィンドウの上端の位置.
  /// @param zNear 視点から前方面までの位置.
  /// @param zFar 視点から後方面までの位置.
  /// @return 求めた透視投影変換行列.
  ///
  inline GgMatrix ggFrustum(
    GLfloat left, GLfloat right,
    GLfloat bottom, GLfloat top,
    GLfloat zNear, GLfloat zFar
  )
  {
    GgMatrix m;
    return m.loadFrustum(left, right, bottom, top, zNear, zFar);
  }

  ///
  /// 画角を指定して透視投影変換行列を返す.
  ///
  /// @param fovy y 方向の画角.
  /// @param aspect 縦横比.
  /// @param zNear 視点から前方面までの位置.
  /// @param zFar 視点から後方面までの位置.
  /// @return 求めた透視投影変換行列.
  ///
  inline GgMatrix ggPerspective(
    GLfloat fovy, GLfloat aspect,
    GLfloat zNear, GLfloat zFar
  )
  {
    GgMatrix m;
    return m.loadPerspective(fovy, aspect, zNear, zFar);
  }

  ///
  /// 転置行列を返す.
  ///
  /// @param m 元の変換行列.
  /// @return m の転置行列.
  ///
  inline GgMatrix ggTranspose(const GgMatrix& m)
  {
    return m.transpose();
  }

  ///
  /// 逆行列を返す.
  ///
  /// @param m 元の変換行列.
  /// @return m の逆行列.
  ///
  inline GgMatrix ggInvert(const GgMatrix& m)
  {
    return m.invert();
  }

  ///
  /// 法線変換行列を返す.
  ///
  /// @param m 元の変換行列.
  /// @return m の法線変換行列.
  ///
  inline GgMatrix ggNormal(const GgMatrix& m)
  {
    return m.normal();
  }

  ///
  /// 四元数.
  ///
  class GgQuaternion : public GgVector
  {
    // GgQuaternion 型の四元数 p と四元数 q の積を四元数 r に求める
    void multiply(GLfloat* r, const GLfloat* p, const GLfloat* q) const;

    // GgQuaternion 型の四元数 q が表す回転の変換行列を m に求める
    void toMatrix(GLfloat* m, const GLfloat* q) const;

    // 回転の変換行列 m が表す四元数を q に求める
    void toQuaternion(GLfloat* q, const GLfloat* m) const;

    // 球面線形補間 q と r を t で補間した四元数を p に求める
    void slerp(GLfloat* p, const GLfloat* q, const GLfloat* r, GLfloat t) const;

  public:

    ///
    /// コンストラクタ.
    ///
    GgQuaternion()
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param x 四元数の x 要素.
    /// @param y 四元数の y 要素.
    /// @param z 四元数の z 要素.
    /// @param w 四元数の w 要素.
    ///
    constexpr GgQuaternion(GLfloat x, GLfloat y, GLfloat z, GLfloat w) :
      GgVector{ x, y, z, w }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param c GLfloat 型の値.
    ///
    constexpr GgQuaternion(GLfloat c) :
      GgQuaternion{ c, c, c, c }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    ///
    GgQuaternion(const GLfloat* a) :
      GgQuaternion{ a[0], a[1], a[2], a[3] }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    ///
    GgQuaternion(const GgVector& v) :
      GgQuaternion{ v[0], v[1], v[2], v[3] }
    {
    }

    ///
    /// 四元数のノルムを求める.
    ///
    /// @return 四元数のノルム.
    ///
    GLfloat norm() const
    {
      return ggLength4(*this);
    }

    ///
    /// 四元数を格納する.
    ///
    /// @param x 四元数の x 要素.
    /// @param y 四元数の y 要素.
    /// @param z 四元数の z 要素.
    /// @param w 四元数の w 要素.
    /// @return 設定した四元数.
    ///
    GgQuaternion& load(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
    {
      data()[0] = x;
      data()[1] = y;
      data()[2] = z;
      data()[3] = w;
      return *this;
    }

    ///
    /// 四元数を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return 設定した四元数.
    ///
    GgQuaternion& load(const GLfloat* a)
    {
      return load(a[0], a[1], a[2], a[3]);
    }

    ///
    /// 四元数を格納する.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return 設定した四元数.
    ///
    GgQuaternion& load(const GgVector& v)
    {
      static_cast<GgVector>(*this) = v;
      return *this;
    }

    ///
    /// 四元数を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return 設定した四元数.
    ///
    GgQuaternion& load(const GgQuaternion& q)
    {
      *this = q;
      return *this;
    }

    ///
    /// 四元数に別の四元数を加算した結果を格納する.
    ///
    /// @param x 加える四元数の x 要素.
    /// @param y 加える四元数の y 要素.
    /// @param z 加える四元数の z 要素.
    /// @param w 加える四元数の w 要素.
    /// @return (x, y, z, w) を加えた四元数.
    ///
    GgQuaternion& loadAdd(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
    {
      data()[0] += x;
      data()[1] += y;
      data()[2] += z;
      data()[3] += w;
      return *this;
    }

    ///
    /// 四元数に別の四元数を加算した結果を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return a を加えた四元数.
    ///
    GgQuaternion& loadAdd(const GLfloat* a)
    {
      return loadAdd(a[0], a[1], a[2], a[3]);
    }

    ///
    /// 四元数に別の四元数を加算した結果を格納する.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return v を加えた四元数.
    ///
    GgQuaternion& loadAdd(const GgVector& v)
    {
      return loadAdd(v[0], v[1], v[2], v[3]);
    }

    ///
    /// 四元数に別の四元数を加算した結果を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return q を加えた四元数.
    ///
    GgQuaternion& loadAdd(const GgQuaternion& q)
    {
      return loadAdd(q[0], q[1], q[2], q[3]);
    }

    ///
    /// 四元数から別の四元数を減算した結果を格納する.
    ///
    /// @param x 引く四元数の x 要素.
    /// @param y 引く四元数の y 要素.
    /// @param z 引く四元数の z 要素.
    /// @param w 引く四元数の w 要素.
    /// @return (x, y, z, w) を引いた四元数.
    ///
    GgQuaternion& loadSubtract(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
    {
      data()[0] -= x;
      data()[1] -= y;
      data()[2] -= z;
      data()[3] -= w;
      return *this;
    }

    ///
    /// 四元数から別の四元数を減算した結果を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return a を引いた四元数.
    ///
    GgQuaternion& loadSubtract(const GLfloat* a)
    {
      return loadSubtract(a[0], a[1], a[2], a[3]);
    }

    ///
    /// 四元数から別の四元数を減算した結果を格納する.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return v を引いた四元数.
    ///
    GgQuaternion& loadSubtract(const GgVector& v)
    {
      return loadSubtract(v[0], v[1], v[2], v[3]);
    }

    ///
    /// 四元数から別の四元数を減算した結果を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return q を引いた四元数.
    ///
    GgQuaternion& loadSubtract(const GgQuaternion& q)
    {
      return loadSubtract(q[0], q[1], q[2], q[3]);
    }

    ///
    /// 四元数に別の四元数を乗算した結果を格納する.
    ///
    /// @param x 掛ける四元数の x 要素.
    /// @param y 掛ける四元数の y 要素.
    /// @param z 掛ける四元数の z 要素.
    /// @param w 掛ける四元数の w 要素.
    /// @return (x, y, z, w) を掛けた四元数.
    ///
    GgQuaternion& loadMultiply(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
    {
      const GLfloat a[]{ x, y, z, w };
      return loadMultiply(a);
    }

    ///
    /// 四元数に別の四元数を乗算した結果を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return a を乗じた四元数.
    ///
    GgQuaternion& loadMultiply(const GLfloat* a)
    {
      return load(multiply(a));
    }

    ///
    /// 四元数に別の四元数を乗算した結果を格納する.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return v を乗じた四元数.
    ///
    GgQuaternion& loadMultiply(const GgVector& v)
    {
      return loadMultiply(v.data());
    }

    ///
    /// 四元数に別の四元数を乗算した結果を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return q を乗じた四元数.
    ///
    GgQuaternion& loadMultiply(const GgQuaternion& q)
    {
      return loadMultiply(q.data());
    }

    ///
    /// 四元を別の四元数で除算した結果を格納する.
    ///
    /// @param x 割る四元数の x 要素.
    /// @param y 割る四元数の y 要素.
    /// @param z 割る四元数の z 要素.
    /// @param w 割る四元数の w 要素.
    /// @return (x, y, z, w) を割った四元数.
    ///
    GgQuaternion& loadDivide(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
    {
      const GLfloat a[]{ x, y, z, w };
      return loadDivide(a);
    }

    ///
    /// 四元を別の四元数で除算した結果を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return a で割った四元数.
    ///
    GgQuaternion& loadDivide(const GLfloat* a)
    {
      return load(divide(a));
    }

    ///
    /// 四元を別の四元数で除算した結果を格納する.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return v で割った四元数.
    ///
    GgQuaternion& loadDivide(const GgVector& v)
    {
      return loadDivide(v.data());
    }

    ///
    /// 四元を別の四元数で除算した結果を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return q で割った四元数.
    ///
    GgQuaternion& loadDivide(const GgQuaternion& q)
    {
      return loadDivide(q.data());
    }

    ///
    /// 四元数に別の四元数を加算した結果を返す.
    ///
    /// @param x 加える四元数の x 要素.
    /// @param y 加える四元数の y 要素.
    /// @param z 加える四元数の z 要素.
    /// @param w 加える四元数の w 要素.
    /// @return (x, y, z, w) を加えた四元数.
    ///
    GgQuaternion add(GLfloat x, GLfloat y, GLfloat z, GLfloat w) const
    {
      GgQuaternion s{ *this };
      return s.loadAdd(x, y, z, w);
    }

    ///
    /// 四元数に別の四元数を加算した結果を返す.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return a を加えた四元数.
    ///
    GgQuaternion add(const GLfloat* a) const
    {
      return add(a[0], a[1], a[2], a[3]);
    }

    ///
    /// 四元数に別の四元数を加算した結果を返す.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return v を加えた四元数.
    ///
    GgQuaternion add(const GgVector& v) const
    {
      return add(v[0], v[1], v[2], v[3]);
    }

    ///
    /// 四元数に別の四元数を加算した結果を返す.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return q を加えた四元数.
    ///
    GgQuaternion add(const GgQuaternion& q) const
    {
      return add(q[0], q[1], q[2], q[3]);
    }

    ///
    /// 四元数から別の四元数を減算した結果を返す.
    ///
    /// @param x 引く四元数の x 要素.
    /// @param y 引く四元数の y 要素.
    /// @param z 引く四元数の z 要素.
    /// @param w 引く四元数の w 要素.
    /// @return (x, y, z, w) を引いた四元数.
    ///
    GgQuaternion subtract(GLfloat x, GLfloat y, GLfloat z, GLfloat w) const
    {
      GgQuaternion s{ *this };
      return s.loadSubtract(x, y, z, w);
    }

    ///
    /// 四元数から別の四元数を減算した結果を返す.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return a を引いた四元数.
    ///
    GgQuaternion subtract(const GLfloat* a) const
    {
      return subtract(a[0], a[1], a[2], a[3]);
    }

    ///
    /// 四元数から別の四元数を減算した結果を返す.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return v を引いた四元数.
    ///
    GgQuaternion subtract(const GgVector& v) const
    {
      return subtract(v[0], v[1], v[2], v[3]);
    }

    ///
    /// 四元数から別の四元数を減算した結果を返す.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return q を引いた四元数.
    ///
    GgQuaternion subtract(const GgQuaternion& q) const
    {
      return subtract(q[0], q[1], q[2], q[3]);
    }

    ///
    /// 四元数に別の四元数を乗算した結果を返す.
    ///
    /// @param x 掛ける四元数の x 要素.
    /// @param y 掛ける四元数の y 要素.
    /// @param z 掛ける四元数の z 要素.
    /// @param w 掛ける四元数の w 要素.
    /// @return (x, y, z, w) を掛けた四元数.
    ///
    GgQuaternion multiply(GLfloat x, GLfloat y, GLfloat z, GLfloat w) const
    {
      const GLfloat a[]{ x, y, z, w };
      return multiply(a);
    }

    ///
    /// 四元数に別の四元数を乗算した結果を返す.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return a を掛けた四元数.
    ///
    GgQuaternion multiply(const GLfloat* a) const
    {
      GgQuaternion s;
      multiply(s.data(), data(), a);
      return s;
    }

    ///
    /// 四元数に別の四元数を乗算した結果を返す.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return v を掛けた四元数.
    ///
    GgQuaternion multiply(const GgVector& v) const
    {
      return multiply(v.data());
    }

    ///
    /// 四元数に別の四元数を乗算した結果を返す.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return q を掛けた四元数.
    ///
    GgQuaternion multiply(const GgQuaternion& q) const
    {
      return multiply(q.data());
    }

    ///
    /// 四元数を別の四元数で除算した結果を返す.
    ///
    /// @param x 割る四元数の x 要素.
    /// @param y 割る四元数の y 要素.
    /// @param z 割る四元数の z 要素.
    /// @param w 割る四元数の w 要素.
    /// @return (x, y, z, w) を割った四元数.
    ///
    GgQuaternion divide(GLfloat x, GLfloat y, GLfloat z, GLfloat w) const
    {
      const GLfloat a[]{ x, y, z, w };
      return divide(a);
    }

    ///
    /// 四元数を別の四元数で除算した結果を返す.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return a で割った四元数.
    ///
    GgQuaternion divide(const GLfloat* a) const
    {
      GgQuaternion s, ia;
      ia.loadInvert(a);
      multiply(s.data(), data(), ia.data());
      return s;
    }

    ///
    /// 四元数を別の四元数で除算した結果を返す.
    ///
    /// @param v 四元数を格納した GgVector 型の変数.
    /// @return v で割った四元数.
    ///
    GgQuaternion divide(const GgVector& v) const
    {
      return divide(v.data());
    }

    ///
    /// 四元数を別の四元数で除算した結果を返す.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return q で割った四元数.
    ///
    GgQuaternion divide(const GgQuaternion& q) const
    {
      return divide(q.data());
    }

    // 演算子
    GgQuaternion& operator=(const GLfloat* a)
    {
      return load(a);
    }
    GgQuaternion& operator=(const GgVector& v)
    {
      return load(v);
    }
    GgQuaternion& operator+=(const GLfloat* a)
    {
      return loadAdd(a);
    }
    GgQuaternion& operator+=(const GgVector& v)
    {
      return loadAdd(v);
    }
    GgQuaternion& operator+=(const GgQuaternion& q)
    {
      return loadAdd(q);
    }
    GgQuaternion& operator-=(const GLfloat* a)
    {
      return loadSubtract(a);
    }
    GgQuaternion& operator-=(const GgVector& v)
    {
      return loadSubtract(v);
    }
    GgQuaternion& operator-=(const GgQuaternion& q)
    {
      return operator-=(q.data());
    }
    GgQuaternion& operator*=(const GLfloat* a)
    {
      return loadMultiply(a);
    }
    GgQuaternion& operator*=(const GgVector& v)
    {
      return loadMultiply(v);
    }
    GgQuaternion& operator*=(const GgQuaternion& q)
    {
      return operator*=(q.data());
    }
    GgQuaternion& operator/=(const GLfloat* a)
    {
      return loadDivide(a);
    }
    GgQuaternion& operator/=(const GgVector& v)
    {
      return loadDivide(v);
    }
    GgQuaternion& operator/=(const GgQuaternion& q)
    {
      return operator/=(q.data());
    }
    GgQuaternion operator+(const GLfloat* a) const
    {
      return add(a);
    }
    GgQuaternion operator+(const GgVector& v) const
    {
      return add(v);
    }
    GgQuaternion operator+(const GgQuaternion& q) const
    {
      return operator+(q.data());
    }
    GgQuaternion operator-(const GLfloat* a) const
    {
      return add(a);
    }
    GgQuaternion operator-(const GgVector& v) const
    {
      return add(v);
    }
    GgQuaternion operator-(const GgQuaternion& q) const
    {
      return operator-(q.data());
    }
    GgQuaternion operator*(const GLfloat* a) const
    {
      return multiply(a);
    }
    GgQuaternion operator*(const GgVector& v) const
    {
      return multiply(v);
    }
    GgQuaternion operator*(const GgQuaternion& q) const
    {
      return operator*(q.data());
    }
    GgQuaternion operator/(const GLfloat* a) const
    {
      return divide(a);
    }
    GgQuaternion operator/(const GgVector& v) const
    {
      return divide(v);
    }
    GgQuaternion operator/(const GgQuaternion& q) const
    {
      return operator/(q.data());
    }

    ///
    /// 回転の変換行列を表す四元数を格納する.
    ///
    /// @param a GLfloat 型の 16 要素の変換行列.
    /// @return a による回転の変換に相当する四元数.
    ///
    GgQuaternion& loadMatrix(const GLfloat* a)
    {
      toQuaternion(data(), a);
      return *this;
    }

    ///
    /// 回転の変換行列 m を表す四元数を格納する.
    ///
    /// @param m Ggmatrix 型の変換行列.
    /// @return m による回転の変換に相当する四元数.
    ///
    GgQuaternion& loadMatrix(const GgMatrix& m)
    {
      return loadMatrix(m.get());
    }

    ///
    /// 単位元を格納する.
    ///
    /// @return 格納された単位元.
    ///
    GgQuaternion& loadIdentity()
    {
      return load(0.0f, 0.0f, 0.0f, 1.0f);
    }

    ///
    /// (x, y, z) を軸として角度 a 回転する四元数を格納する.
    ///
    /// @param x 軸ベクトルの x 成分.
    /// @param y 軸ベクトルの y 成分.
    /// @param z 軸ベクトルの z 成分.
    /// @param a 回転角.
    /// @return 格納された回転を表す四元数.
    ///
    GgQuaternion& loadRotate(GLfloat x, GLfloat y, GLfloat z, GLfloat a);

    ///
    /// (v[0], v[1], v[2]) を軸として角度 a 回転する四元数を格納する.
    ///
    /// @param v 軸ベクトルを表す GLfloat 型の 3 要素の配列変数.
    /// @param a 回転角.
    /// @return 格納された回転を表す四元数.
    ///
    GgQuaternion& loadRotate(const GLfloat* v, GLfloat a)
    {
      return loadRotate(v[0], v[1], v[2], a);
    }

    ///
    /// (v[0], v[1], v[2]) を軸として角度 v[3] 回転する四元数を格納する.
    ///
    /// @param v 軸ベクトルと回転角を格納した GLfloat 型の 4 要素の配列変数.
    /// @return 格納された回転を表す四元数.
    ///
    GgQuaternion& loadRotate(const GLfloat* v)
    {
      return loadRotate(v[0], v[1], v[2], v[3]);
    }

    ///
    /// x 軸中心に角度 a 回転する四元数を格納する.
    ///
    /// @param a 回転角.
    /// @return 格納された回転を表す四元数.
    ///
    GgQuaternion& loadRotateX(GLfloat a);

    ///
    /// y 軸中心に角度 a 回転する四元数を格納する.
    ///
    /// @param a 回転角.
    /// @return 格納された回転を表す四元数.
    ///
    GgQuaternion& loadRotateY(GLfloat a);

    ///
    /// z 軸中心に角度 a 回転する四元数を格納する.
    ///
    /// @param a 回転角.
    /// @return 格納された回転を表す四元数.
    ///
    GgQuaternion& loadRotateZ(GLfloat a);

    ///
    /// 四元数を (x, y, z) を軸として角度 a 回転した四元数を返す.
    ///
    /// @param x 軸ベクトルの x 成分.
    /// @param y 軸ベクトルの y 成分.
    /// @param z 軸ベクトルの z 成分.
    /// @param a 回転角.
    /// @return 回転した四元数.
    ///
    GgQuaternion rotate(GLfloat x, GLfloat y, GLfloat z, GLfloat a) const
    {
      GgQuaternion q;
      return multiply(q.loadRotate(x, y, z, a));
    }

    ///
    /// 四元数を (v[0], v[1], v[2]) を軸として角度 a 回転した四元数を返す.
    ///
    /// @param v 軸ベクトルを表す GLfloat 型の 3 要素の配列変数.
    /// @param a 回転角.
    /// @return 回転した四元数.
    ///
    GgQuaternion rotate(const GLfloat* v, GLfloat a) const
    {
      return rotate(v[0], v[1], v[2], a);
    }

    ///
    /// 四元数を (v[0], v[1], v[2]) を軸として角度 v[3] 回転した四元数を返す.
    ///
    /// @param v 軸ベクトルを表す GLfloat 型の 4 要素の配列変数.
    /// @return 回転した四元数.
    ///
    GgQuaternion rotate(const GLfloat* v) const
    {
      return rotate(v[0], v[1], v[2], v[3]);
    }

    ///
    /// 四元数を x 軸中心に角度 a 回転した四元数を返す.
    ///
    /// @param a 回転角.
    /// @return 回転した四元数.
    ///
    GgQuaternion rotateX(GLfloat a) const
    {
      return rotate(1.0f, 0.0f, 0.0f, a);
    }

    ///
    /// 四元数を y 軸中心に角度 a 回転した四元数を返す.
    ///
    /// @param a 回転角.
    /// @return 回転した四元数.
    ///
    GgQuaternion rotateY(GLfloat a) const
    {
      return rotate(0.0f, 1.0f, 0.0f, a);
    }

    ///
    /// 四元数を z 軸中心に角度 a 回転した四元数を返す.
    ///
    /// @param a 回転角.
    /// @return 回転した四元数.
    ///
    GgQuaternion rotateZ(GLfloat a) const
    {
      return rotate(0.0f, 0.0f, 1.0f, a);
    }

    ///
    /// オイラー角 (heading, pitch, roll) で与えられた回転を表す四元数を格納する.
    ///
    /// @param heading y 軸中心の回転角.
    /// @param pitch x 軸中心の回転角.
    /// @param roll z 軸中心の回転角.
    /// @return 格納した回転を表す四元数.
    ///
    GgQuaternion& loadEuler(GLfloat heading, GLfloat pitch, GLfloat roll);

    ///
    /// オイラー角 (e[0], e[1], e[2]) で与えられた回転を表す四元数を格納する.
    ///
    /// @param e オイラー角を表す GLfloat 型の 3 要素の配列変数 (heading, pitch, roll).
    /// @return 格納した回転を表す四元数.
    ///
    GgQuaternion& loadEuler(const GLfloat* e)
    {
      return loadEuler(e[0], e[1], e[2]);
    }

    ///
    /// 四元数をオイラー角 (heading, pitch, roll) で回転した四元数を返す.
    ///
    /// @param heading y 軸中心の回転角.
    /// @param pitch x 軸中心の回転角.
    /// @param roll z 軸中心の回転角.
    /// @return 回転した四元数.
    ///
    GgQuaternion euler(GLfloat heading, GLfloat pitch, GLfloat roll) const
    {
      GgQuaternion r;
      return multiply(r.loadEuler(heading, pitch, roll));
    }

    ///
    /// 四元数をオイラー角 (e[0], e[1], e[2]) で回転した四元数を返す.
    ///
    /// @param e オイラー角を表す GLfloat 型の 3 要素の配列変数 (heading, pitch, roll).
    /// @return 回転した四元数.
    ///
    GgQuaternion euler(const GLfloat* e) const
    {
      return euler(e[0], e[1], e[2]);
    }

    ///
    /// 球面線形補間の結果を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @param b 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @param t 補間パラメータ.
    /// @return 格納した a, b を t で内分した四元数.
    ///
    GgQuaternion& loadSlerp(const GLfloat* a, const GLfloat* b, GLfloat t)
    {
      slerp(data(), a, b, t);
      return *this;
    }

    ///
    /// 球面線形補間の結果を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @param r GgQuaternion 型の四元数.
    /// @param t 補間パラメータ.
    /// @return 格納した q, r を t で内分した四元数.
    ///
    GgQuaternion& loadSlerp(const GgQuaternion& q, const GgQuaternion& r, GLfloat t)
    {
      return loadSlerp(q.data(), r.data(), t);
    }

    ///
    /// 球面線形補間の結果を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @param t 補間パラメータ.
    /// @return 格納した q, a を t で内分した四元数.
    ///
    GgQuaternion& loadSlerp(const GgQuaternion& q, const GLfloat* a, GLfloat t)
    {
      return loadSlerp(q.data(), a, t);
    }

    ///
    /// 球面線形補間の結果を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @param q GgQuaternion 型の四元数.
    /// @param t 補間パラメータ.
    /// @return 格納した a, q を t で内分した四元数.
    ///
    GgQuaternion& loadSlerp(const GLfloat* a, const GgQuaternion& q, GLfloat t)
    {
      return loadSlerp(a, q.data(), t);
    }

    ///
    /// 引数に指定した四元数を正規化して格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return 正規化された四元数.
    ///
    GgQuaternion& loadNormalize(const GLfloat* a);

    ///
    /// 引数に指定した四元数を正規化して格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return 正規化された四元数.
    ///
    GgQuaternion& loadNormalize(const GgQuaternion& q)
    {
      return loadNormalize(q.data());
    }

    ///
    /// 引数に指定した四元数の共役四元数を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return 共役四元数.
    ///
    GgQuaternion& loadConjugate(const GLfloat* a);

    ///
    /// 引数に指定した四元数の共役四元数を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return 共役四元数.
    ///
    GgQuaternion& loadConjugate(const GgQuaternion& q)
    {
      return loadConjugate(q.data());
    }

    ///
    /// 引数に指定した四元数の逆元を格納する.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @return 四元数の逆元.
    ///
    GgQuaternion& loadInvert(const GLfloat* a);

    ///
    /// 引数に指定した四元数の逆元を格納する.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @return 四元数の逆元.
    ///
    GgQuaternion& loadInvert(const GgQuaternion& q)
    {
      return loadInvert(q.data());
    }

    ///
    /// 球面線形補間の結果を返す.
    ///
    /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
    /// @param t 補間パラメータ.
    /// @return 四元数を a に対して t で内分した結果.
    ///
    GgQuaternion slerp(GLfloat* a, GLfloat t) const
    {
      GgQuaternion p;
      slerp(p.data(), data(), a, t);
      return p;
    }

    ///
    /// 球面線形補間の結果を返す.
    ///
    /// @param q GgQuaternion 型の四元数.
    /// @param t 補間パラメータ.
    /// @return 四元数を q に対して t で内分した結果.
    ///
    GgQuaternion slerp(const GgQuaternion& q, GLfloat t) const
    {
      GgQuaternion p;
      slerp(p.data(), data(), q.data(), t);
      return p;
    }

    ///
    /// 正規化する.
    ///
    /// @return 正規化された四元数.
    ///
    GgQuaternion normalize() const
    {
      GgQuaternion q;
      q.loadNormalize(data());
      return q;
    }

    ///
    /// 共役四元数に変換する.
    ///
    /// @return 共役四元数.
    ///
    GgQuaternion conjugate() const
    {
      GgQuaternion q;
      q.loadConjugate(data());
      return q;
    }

    ///
    /// 逆元に変換する.
    ///
    /// @return 四元数の逆元.
    ///
    GgQuaternion invert() const
    {
      GgQuaternion q;
      q.loadInvert(data());
      return q;
    }

    ///
    /// 四元数を取り出す.
    ///
    /// @param a 四元数を格納する GLfloat 型の 4 要素の配列変数.
    ///
    void get(GLfloat* a) const
    {
      a[0] = data()[0];
      a[1] = data()[1];
      a[2] = data()[2];
      a[3] = data()[3];
    }

    ///
    /// 四元数が表す回転の変換行列を a に求める.
    ///
    /// @param a 回転の変換行列を格納する GLfloat 型の 16 要素の配列変数.
    ///
    void getMatrix(GLfloat* a) const
    {
      toMatrix(a, data());
    }

    ///
    /// 四元数が表す回転の変換行列を m に求める.
    ///
    /// @param m 回転の変換行列を格納する GgMatrix 型の変数.
    ///
    void getMatrix(GgMatrix& m) const
    {
      getMatrix(m.data());
    }

    ///
    /// 四元数が表す回転の変換行列を取り出す.
    ///
    /// @return 回転の変換を表す GgMatrix 型の変換行列.
    ///
    GgMatrix getMatrix() const
    {
      GgMatrix m;
      getMatrix(m);
      return m;
    }

    ///
    /// 四元数の共役が表す回転の変換行列を a に求める.
    ///
    /// @param a 回転の変換行列を格納する GLfloat 型の 16 要素の配列変数.
    ///
    void getConjugateMatrix(GLfloat* a) const
    {
      GgQuaternion c;
      c.loadConjugate(data());
      toMatrix(a, c.data());
    }

    ///
    /// 四元数の共役が表す回転の変換行列を m に求める.
    ///
    /// @param m 回転の変換行列を格納する GgMatrix 型の変数.
    ///
    void getConjugateMatrix(GgMatrix& m) const
    {
      getConjugateMatrix(m.data());
    }

    ///
    /// 四元数の共役が表す回転の変換行列を取り出す.
    ///
    /// @return 回転の変換を表す GgMatrix 型の変換行列.
    ///
    GgMatrix getConjugateMatrix() const
    {
      GgMatrix m;
      getConjugateMatrix(m);
      return m;
    }
  };

  ///
  /// 四元数を返す.
  ///
  /// @param x 四元数の x 要素.
  /// @param y 四元数の y 要素.
  /// @param z 四元数の z 要素.
  /// @param w 四元数の w 要素.
  /// @return 四元数.
  ///
  inline GgQuaternion ggQuaternion(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
  {
    GgQuaternion q;
    return q.load(x, y, z, w);
  }

  ///
  /// 四元数を返す.
  ///
  /// @param a GLfloat 型の GLfloat 型の 4 要素の配列変数に格納した四元数.
  /// @return 四元数.
  ///
  inline GgQuaternion ggQuaternion(const GLfloat* a)
  {
    return ggQuaternion(a[0], a[1], a[2], a[3]);
  }

  ///
  /// 単位四元数を返す.
  ///
  /// @return 単位四元数.
  ///
  inline GgQuaternion ggIdentityQuaternion()
  {
    GgQuaternion q;
    return q.loadIdentity();
  }

  ///
  /// 回転の変換行列 m を表す四元数を返す.
  ///
  /// @param a GLfloat 型の 16 要素の配列変数.
  /// @return a による回転の変換に相当する四元数.
  ///
  inline GgQuaternion ggMatrixQuaternion(const GLfloat* a)
  {
    GgQuaternion q;
    return q.loadMatrix(a);
  }

  ///
  /// 回転の変換行列 m を表す四元数を返す.
  ///
  /// @param m GgMatrix 型の変換行列.
  /// @return m による回転の変換に相当する四元数.
  ///
  inline GgQuaternion ggMatrixQuaternion(const GgMatrix& m)
  {
    return ggMatrixQuaternion(m.get());
  }

  ///
  /// 四元数 q の回転の変換行列を返す.
  ///
  /// @param q 元の四元数.
  /// @return 四元数 q が表す回転に相当する GgMatrix 型の変換行列.
  ///
  inline GgMatrix ggQuaternionMatrix(const GgQuaternion& q)
  {
    GLfloat m[16];
    q.getMatrix(m);
    return GgMatrix{ m };
  }

  ///
  /// 四元数 q の回転の転置した変換行列を返す.
  ///
  /// @param q 元の四元数.
  /// @return 四元数 q が表す回転に相当する転置した GgMatrix 型の変換行列.
  ///
  inline GgMatrix ggQuaternionTransposeMatrix(const GgQuaternion& q)
  {
    GLfloat m[16];
    q.getMatrix(m);
    GgMatrix t;
    return t.loadTranspose(m);
  }

  ///
  /// (x, y, z) を軸として角度 a 回転する四元数を返す.
  ///
  /// @param x 軸ベクトルの x 成分.
  /// @param y 軸ベクトルの y 成分.
  /// @param z 軸ベクトルの z 成分.
  /// @param a 回転角.
  /// @return 回転を表す四元数.
  ///
  inline GgQuaternion ggRotateQuaternion(GLfloat x, GLfloat y, GLfloat z, GLfloat a)
  {
    GgQuaternion q;
    return q.loadRotate(x, y, z, a);
  }

  ///
  /// (v[0], v[1], v[2]) を軸として角度 a 回転する四元数を返す.
  ///
  /// @param v 軸ベクトルを表す GLfloat 型の 3 要素の配列変数.
  /// @param a 回転角.
  /// @return 回転を表す四元数.
  ///
  inline GgQuaternion ggRotateQuaternion(const GLfloat* v, GLfloat a)
  {
    return ggRotateQuaternion(v[0], v[1], v[2], a);
  }

  ///
  /// (v[0], v[1], v[2]) を軸として角度 v[3] 回転する四元数を返す.
  ///
  /// @param v 軸ベクトルを表す GLfloat 型の 4 要素の配列変数.
  /// @return 回転を表す四元数.
  ///
  inline GgQuaternion ggRotateQuaternion(const GLfloat* v)
  {
    return ggRotateQuaternion(v[0], v[1], v[2], v[3]);
  }

  ///
  /// オイラー角 (heading, pitch, roll) で与えられた回転を表す四元数を返す.
  ///
  /// @param heading y 軸中心の回転角.
  /// @param pitch x 軸中心の回転角.
  /// @param roll z 軸中心の回転角.
  /// @return 回転を表す四元数.
  ///
  inline GgQuaternion ggEulerQuaternion(GLfloat heading, GLfloat pitch, GLfloat roll)
  {
    GgQuaternion q;
    return q.loadEuler(heading, pitch, roll);
  }

  ///
  /// オイラー角 (e[0], e[1], e[2]) で与えられた回転を表す四元数を返す.
  ///
  /// @param e オイラー角を表す GLfloat 型の 3 要素の配列変数 (heading, pitch, roll).
  /// @return 回転を表す四元数.
  ///
  inline GgQuaternion ggEulerQuaternion(const GLfloat* e)
  {
    return ggEulerQuaternion(e[0], e[1], e[2]);
  }

  ///
  /// 二つの四元数の球面線形補間の結果を返す.
  ///
  /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
  /// @param b 四元数を格納した GLfloat 型の 4 要素の配列変数.
  /// @param t 補間パラメータ.
  /// @return a, b を t で内分した四元数.
  ///
  inline GgQuaternion ggSlerp(const GLfloat* a, const GLfloat* b, GLfloat t)
  {
    GgQuaternion r;
    return r.loadSlerp(a, b, t);
  }

  ///
  /// 二つの四元数の球面線形補間の結果を返す.
  ///
  /// @param q GgQuaternion 型の四元数.
  /// @param r GgQuaternion 型の四元数.
  /// @param t 補間パラメータ.
  /// @return q, r を t で内分した四元数.
  ///
  inline GgQuaternion ggSlerp(const GgQuaternion& q, const GgQuaternion& r, GLfloat t)
  {
    return ggSlerp(q.data(), r.data(), t);
  }

  ///
  /// 二つの四元数の球面線形補間の結果を返す.
  ///
  /// @param q GgQuaternion 型の四元数.
  /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
  /// @param t 補間パラメータ.
  /// @return q, a を t で内分した四元数.
  ///
  inline GgQuaternion ggSlerp(const GgQuaternion& q, const GLfloat* a, GLfloat t)
  {
    return ggSlerp(q.data(), a, t);
  }

  ///
  /// 二つの四元数の球面線形補間の結果を返す.
  ///
  /// @param a 四元数を格納した GLfloat 型の 4 要素の配列変数.
  /// @param q GgQuaternion 型の四元数.
  /// @param t 補間パラメータ.
  /// @return a, q を t で内分した四元数.
  ///
  inline GgQuaternion ggSlerp(const GLfloat* a, const GgQuaternion& q, GLfloat t)
  {
    return ggSlerp(a, q.data(), t);
  }

  ///
  /// 四元数のノルムを返す.
  ///
  /// @param q GgQuaternion 型の四元数.
  /// @return 四元数 q のノルム.
  ///
  inline GLfloat ggNorm(const GgQuaternion& q)
  {
    return q.norm();
  }

  ///
  /// 正規化した四元数を返す.
  ///
  /// @param q GgQuaternion 型の四元数.
  /// @return 四元数 q を正規化した四元数.
  ///
  inline GgQuaternion ggNormalize(const GgQuaternion& q)
  {
    return q.normalize();
  }

  ///
  /// 共役四元数を返す.
  ///
  /// @param q GgQuaternion 型の四元数.
  /// @return 四元数 q の共役四元数.
  ///
  inline GgQuaternion ggConjugate(const GgQuaternion& q)
  {
    return q.conjugate();
  }

  ///
  /// 四元数の逆元を求める.
  ///
  /// @param q GgQuaternion 型の四元数.
  /// @return 四元数 q の逆元.
  ///
  inline GgQuaternion ggInvert(const GgQuaternion& q)
  {
    return q.invert();
  }

  ///
  /// 簡易トラックボール処理.
  ///
  class GgTrackball : public GgQuaternion
  {
    bool drag;        // ドラッグ中か否か
    GLfloat start[2]; // ドラッグ開始位置
    GLfloat scale[2]; // マウスの絶対位置→ウィンドウ内での相対位置の換算係数
    GgQuaternion cq;  // 回転の初期値 (四元数)
    GgMatrix rt;      // 回転の変換行列

  public:

    ///
    /// コンストラクタ.
    ///
    /// @param q トラックボールの回転の初期値の四元数.
    ///
    GgTrackball(const GgQuaternion& q = ggIdentityQuaternion())
    {
      reset(q);
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgTrackball()
    {
    }

    ///
    /// 代入.
    ///
    /// @param q トラックボールの回転の初期値の四元数.
    ///
    GgTrackball& operator=(const GgQuaternion& q)
    {
      this->load(q);
      return *this;
    }

    ///
    /// トラックボール処理するマウスの移動範囲を指定する.
    ///
    /// @param w 領域の横幅.
    /// @param h 領域の高さ.
    ///
    /// @note
    /// ウィンドウのリサイズ時に呼び出す.
    ///
    void region(GLfloat w, GLfloat h);

    ///
    /// トラックボール処理するマウスの移動範囲を指定する.
    ///
    /// @param w 領域の横幅.
    /// @param h 領域の高さ.
    ///
    /// @note
    /// ウィンドウのリサイズ時に呼び出す.
    ///
    void region(int w, int h)
    {
      region(static_cast<GLfloat>(w), static_cast<GLfloat>(h));
    }

    ///
    /// トラックボール処理を開始する.
    ///
    /// @param x 現在のマウスの x 座標.
    /// @param y 現在のマウスの y 座標.
    ///
    /// @note
    /// マウスのドラッグ開始時 (マウスボタンを押したとき) に呼び出す.
    ///
    void begin(GLfloat x, GLfloat y);

    ///
    /// 回転の変換行列を計算する.
    ///
    /// @param x 現在のマウスの x 座標.
    /// @param y 現在のマウスの y 座標.
    ///
    /// @note
    /// マウスのドラッグ中に呼び出す.
    ///
    void motion(GLfloat x, GLfloat y);

    ///
    /// トラックボールの回転角を修正する.
    ///
    /// @param q 修正分の回転角の四元数.
    ///
    void rotate(const GgQuaternion& q);

    ///
    /// トラックボール処理を停止する.
    ///
    /// @param x 現在のマウスの x 座標.
    /// @param y 現在のマウスの y 座標.
    ///
    /// @note
    /// マウスのドラッグ終了時 (マウスボタンを離したとき) に呼び出す.
    ///
    void end(GLfloat x, GLfloat y);

    ///
    /// トラックボールをリセットする.
    ///
    /// @param q トラックボールの回転の初期値の四元数.
    ///
    void reset(const GgQuaternion& q = ggIdentityQuaternion());

    ///
    /// トラックボール処理の開始位置を取り出す.
    ///
    /// @return トラックボールの開始位置のポインタ.
    ///
    const GLfloat* getStart() const
    {
      return start;
    }

    ///
    /// トラックボール処理の開始位置を取り出す.
    /// @param direction 0 なら x 方向, 1 なら y 方向.
    const GLfloat& getStart(int direction) const
    {
      return start[direction];
    }

    ///
    /// トラックボール処理の開始位置を取り出す.
    ///
    /// @param position トラックボールの開始位置を格納する 2 要素の配列.
    ///
    void getStart(GLfloat* position) const
    {
      position[0] = start[0];
      position[1] = start[1];
    }

    ///
    /// トラックボール処理の換算係数を取り出す.
    ///
    /// @return トラックボールの換算係数のポインタ.
    ///
    const GLfloat* getScale() const
    {
      return scale;
    }

    ///
    /// トラックボール処理の換算係数を取り出す.
    ///
    /// @param direction 0 なら x 方向, 1 なら y 方向.
    ///
    const GLfloat getScale(int direction) const
    {
      return scale[direction];
    }

    ///
    /// トラックボール処理の換算係数を取り出す.
    ///
    /// @param factor トラックボールの換算係数を格納する 2 要素の配列.
    ///
    void getScale(GLfloat* factor) const
    {
      factor[0] = scale[0];
      factor[1] = scale[1];
    }

    ///
    /// 現在の回転の四元数を取り出す.
    ///
    /// @return 回転の変換を表す Quaternion 型の四元数.
    ///
    const GgQuaternion& getQuaternion() const
    {
      return *this;
    }

    ///
    /// 現在の回転の変換行列を取り出す.
    ///
    /// @return 回転の変換を表す GgMatrix 型の変換行列.
    ///
    const GgMatrix& getMatrix() const
    {
      return rt;
    }

    ///
    /// 現在の回転の変換行列を取り出す.
    ///
    /// @return 回転の変換を表す GLfloat 型の 16 要素の配列.
    ///
    const GLfloat* get() const
    {
      return rt.get();
    }
  };

  ///
  /// 配列の内容を TGA ファイルに保存する.
  ///
  /// @param name 保存するファイル名.
  /// @param buffer 画像データを格納した配列.
  /// @param width 画像の横の画素数.
  /// @param height 画像の縦の画素数.
  /// @param depth 1画素のバイト数.
  /// @return 保存に成功すれば true, 失敗すれば false.
  ///
  extern bool ggSaveTga(
    const std::string& name,
    const void* buffer,
    unsigned int width,
    unsigned int height,
    unsigned int depth
  );

  ///
  /// カラーバッファの内容を TGA ファイルに保存する.
  ///
  /// @param name 保存するファイル名.
  /// @return 保存に成功すれば true, 失敗すれば false.
  ///
  extern bool ggSaveColor(const std::string& name);

  ///
  /// デプスバッファの内容を TGA ファイルに保存する.
  ///
  /// @param name 保存するファイル名.
  /// @return 保存に成功すれば true, 失敗すれば false.
  ///
  extern bool ggSaveDepth(const std::string& name);

  ///
  /// TGA ファイル (8/16/24/32bit) をメモリに読み込む.
  ///
  /// @param name 読み込むファイル名.
  /// @param image 読み込んだデータを格納する vector.
  /// @param pWidth 読み込んだ画像の横の画素数の格納先のポインタ, nullptr なら格納しない.
  /// @param pHeight 読み込んだ画像の縦の画素数の格納先のポインタ, nullptr なら格納しない.
  /// @param pFormat 読み込んだファイルの書式 (GL_RED, G_RG, GL_RGB, G_RGBA) の格納先のポインタ, nullptr なら格納しない.
  /// @return 読み込みに成功すれば true, 失敗すれば false.
  ///
  extern bool ggReadImage(
    const std::string& name,
    std::vector<GLubyte>& image,
    GLsizei* pWidth,
    GLsizei* pHeight,
    GLenum* pFormat
  );

  ///
  /// テクスチャを作成して確保して画像データをテクスチャとして読み込む.
  ///
  /// @param image テクスチャとして読み込むデータ, nullptr ならテクスチャの作成のみを行う.
  /// @param width テクスチャとして読み込むデータ image の横の画素数.
  /// @param height テクスチャとして読み込むデータ image の縦の画素数.
  /// @param format image のフォーマット.
  /// @param type image のデータ型.
  /// @param internal テクスチャの内部フォーマット.
  /// @param wrap テクスチャのラッピングモード, デフォルトは GL_CLAMP_TO_EDGE.
  /// @param swizzle true ならテクスチャの赤と青を入れ替える, デフォルトは true.
  /// @return テクスチャの作成に成功すればテクスチャ名, 失敗すれば 0.
  ///
  extern GLuint ggLoadTexture(
    const GLvoid* image,
    GLsizei width,
    GLsizei height,
    GLenum format = GL_RGB,
    GLenum type = GL_UNSIGNED_BYTE,
    GLenum internal = GL_RGB,
    GLenum wrap = GL_CLAMP_TO_EDGE,
    bool swizzle = true
  );

  ///
  /// テクスチャを作成して TGA フォーマットの画像ファイルを読み込む.
  ///
  /// @param name 読み込むファイル名.
  /// @param pWidth 読みだした画像ファイルの横の画素数の格納先のポインタ (nullptr なら格納しない).
  /// @param pHeight 読みだした画像ファイルの縦の画素数の格納先のポインタ (nullptr なら格納しない).
  /// @param internal glTexImage2D() に指定するテクスチャの内部フォーマット, 0 なら外部フォーマットに合わせる.
  /// @param wrap テクスチャのラッピングモード, デフォルトは GL_CLAMP_TO_EDGE.
  /// @return テクスチャの作成に成功すればテクスチャ名, 失敗すれば 0.
  ///
  extern GLuint ggLoadImage(
    const std::string& name,
    GLsizei* pWidth = nullptr,
    GLsizei* pHeight = nullptr,
    GLenum internal = 0,
    GLenum wrap = GL_CLAMP_TO_EDGE
  );

  ///
  /// グレースケール画像 (8bit) から法線マップのデータを作成する.
  ///
  /// @param hmap グレースケール画像のデータ.
  /// @param width 高さマップのグレースケール画像 hmap の横の画素数.
  /// @param height 高さマップのグレースケール画像 hmap の縦の画素数.
  /// @param format データの書式 (GL_RED, GL_RG, GL_RGB, GL_RGBA).
  /// @param nz 法線の z 成分の割合.
  /// @param internal 法線マップを格納するテクスチャの内部フォーマット.
  /// @param nmap 法線マップを格納する vector.
  ///
  extern void ggCreateNormalMap(
    const GLubyte* hmap,
    GLsizei width,
    GLsizei height,
    GLenum format,
    GLfloat nz,
    GLenum internal,
    std::vector<GgVector>& nmap
  );

  ///
  /// TGA 画像ファイルの高さマップ読み込んで法線マップのテクスチャを作成する.
  ///
  /// @param name 読み込むファイル名.
  /// @param nz 法線の z 成分の割合.
  /// @param pWidth 読みだした画像ファイルの横の画素数の格納先のポインタ (nullptr なら格納しない).
  /// @param pHeight 読みだした画像ファイルの縦の画素数の格納先のポインタ (nullptr なら格納しない).
  /// @param internal glTexImage2D() に指定するテクスチャの内部フォーマット.
  /// @return テクスチャの作成に成功すればテクスチャ名, 失敗すれば 0.
  ///
  extern GLuint ggLoadHeight(
    const std::string& name,
    GLfloat nz,
    GLsizei* pWidth = nullptr,
    GLsizei* pHeight = nullptr,
    GLenum internal = GL_RGBA
  );

  ///
  /// シェーダのソースプログラムの文字列を読み込んでプログラムオブジェクトを作成する.
  ///
  /// @param vsrc バーテックスシェーダのソースプログラムの文字列.
  /// @param fsrc フラグメントシェーダのソースプログラムの文字列 (空文字列なら不使用).
  /// @param gsrc ジオメトリシェーダのソースプログラムの文字列 (空文字列なら不使用).
  /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
  /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
  /// @param vtext バーテックスシェーダのコンパイル時のメッセージに追加する文字列.
  /// @param ftext フラグメントシェーダのコンパイル時のメッセージに追加する文字列.
  /// @param gtext ジオメトリシェーダのコンパイル時のメッセージに追加する文字列.
  /// @return プログラムオブジェクトのプログラム名 (作成できなければ 0).
  ///
  extern GLuint ggCreateShader(
    const std::string& vsrc,
    const std::string& fsrc = "",
    const std::string& gsrc = "",
    GLint nvarying = 0,
    const char* const* varyings = nullptr,
    const std::string& vtext = "vertex shader",
    const std::string& ftext = "fragment shader",
    const std::string& gtext = "geometry shader");

  ///
  /// シェーダのソースファイルを読み込んでプログラムオブジェクトを作成する.
  ///
  /// @param vert バーテックスシェーダのソースファイル名.
  /// @param frag フラグメントシェーダのソースファイル名 (空文字列なら不使用).
  /// @param geom ジオメトリシェーダのソースファイル名 (空文字列なら不使用).
  /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
  /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
  /// @return プログラムオブジェクトのプログラム名 (作成できなければ 0).
  ///
  extern GLuint ggLoadShader(
    const std::string& vert,
    const std::string& frag = "",
    const std::string& geom = "",
    GLint nvarying = 0,
    const char* const* varyings = nullptr
  );

  ///
  /// シェーダのソースファイルを読み込んでプログラムオブジェクトを作成する.
  ///
  /// @param files バーテックスシェーダのソースファイル名の配列.
  /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
  /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
  /// @return プログラムオブジェクトのプログラム名 (作成できなければ 0).
  ///
  inline GLuint ggLoadShader(
    const std::array<std::string, 3>& files,
    GLint nvarying = 0,
    const char* const* varyings = nullptr
  )
  {
    return ggLoadShader(files[0], files[1], files[2], nvarying, varyings);
  }

#if !defined(__APPLE__)
  ///
  /// コンピュートシェーダのソースプログラムの文字列を読み込んでプログラムオブジェクトを作成する.
  ///
  /// @param csrc コンピュートシェーダのソースプログラムの文字列.
  /// @param ctext コンピュートシェーダのコンパイル時のメッセージに追加する文字列.
  /// @return プログラムオブジェクトのプログラム名 (作成できなければ 0).
  ///
  extern GLuint ggCreateComputeShader(
    const std::string& csrc,
    const std::string& ctext = "compute shader"
  );

  ///
  /// コンピュートシェーダのソースファイルを読み込んでプログラムオブジェクトを作成する.
  ///
  /// @param comp コンピュートシェーダのソースファイル名.
  /// @returnプログラムオブジェクトのプログラム名 (作成できなければ 0).
  ///
  extern GLuint ggLoadComputeShader(const std::string& comp);
#endif

  ///
  /// テクスチャ.
  ///
  /// @note
  /// 画像データを読み込んでテクスチャマップを作成する.
  ///
  class GgTexture
  {
    // テクスチャ名
    GLuint texture;

    // テクスチャの縦横の画素数
    GLsizei size[2];

  public:

    ///
    /// メモリ上のデータからテクスチャを作成するコンストラクタ.
    ///
    /// @param image テクスチャとして用いる画像データ, nullptr ならデータを読み込まない.
    /// @param width テクスチャの横の画素数.
    /// @param height テクスチャの縦の画素数.
    /// @param format 読み込む画像のフォーマット.
    /// @param type 画像のデータ型.
    /// @param internal テクスチャの内部フォーマット.
    /// @param wrap テクスチャのラッピングモード, デフォルトは GL_CLAMP_TO_EDGE.
    /// @param swizzle true ならテクスチャの赤と青を入れ替える, デフォルトは true.
    ///
    GgTexture(
      const GLvoid* image,
      GLsizei width,
      GLsizei height,
      GLenum format = GL_RGB,
      GLenum type = GL_UNSIGNED_BYTE,
      GLenum internal = GL_RGBA,
      GLenum wrap = GL_CLAMP_TO_EDGE,
      bool swizzle = true
    ) :
      texture{ ggLoadTexture(image, width, height, format, type, internal, wrap, swizzle) },
      size{ width, height }
    {
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgTexture()
    {
      glBindTexture(GL_TEXTURE_2D, 0);
      glDeleteTextures(1, &texture);
    }

    ///
    /// コピーコンストラクタは使用禁止.
    ///
    GgTexture(const GgTexture& o) = delete;

    ///
    /// 代入演算子は使用禁止.
    ///
    GgTexture& operator=(const GgTexture& o) = delete;

    ///
    /// テクスチャの使用開始 (このテクスチャを使用する際に呼び出す).
    ///
    void bind() const
    {
      glBindTexture(GL_TEXTURE_2D, texture);
    }

    ///
    /// テクスチャの使用終了 (このテクスチャを使用しなくなったら呼び出す).
    ///
    void unbind() const
    {
      glBindTexture(GL_TEXTURE_2D, 0);
    }

    ///
    /// テクスチャの赤と青を交換する
    ///
    /// @param swizzle 赤と青を交換するなら true
    ///
    void swapRandB(bool swizzle) const;

    ///
    /// 使用しているテクスチャの横の画素数を取り出す.
    ///
    /// @return テクスチャの横の画素数.
    ///
    const GLsizei& getWidth() const
    {
      return size[0];
    }

    ///
    /// 使用しているテクスチャの縦の画素数を取り出す.
    ///
    /// @return テクスチャの縦の画素数.
    ///
    const GLsizei& getHeight() const
    {
      return size[1];
    }

    ///
    /// 使用しているテクスチャのサイズを取り出す.
    ///
    /// @param size テクスチャのサイズを格納する GLsizei 型の 2 要素の配列変数.
    ///
    void getSize(GLsizei* size) const
    {
      size[0] = getWidth();
      size[1] = getHeight();
    }

    ///
    /// 使用しているテクスチャのサイズを取り出す.
    ///
    /// @return テクスチャのサイズを格納した配列へのポインタ.
    ///
    const GLsizei* getSize() const
    {
      return size;
    }

    ///
    /// 使用しているテクスチャのテクスチャ名を得る.
    ///
    /// @return テクスチャ名.
    ///
    const GLuint& getTexture() const
    {
      return texture;
    }
  };

  ///
  /// カラーマップ.
  ///
  /// @note
  /// カラー画像を読み込んでテクスチャを作成する.
  ///
  class GgColorTexture
  {
    // テクスチャ
    std::shared_ptr<GgTexture> texture;

  public:

    ///
    /// コンストラクタ.
    ///
    GgColorTexture()
    {
    }

    ///
    /// メモリ上のデータからカラーのテクスチャを作成するコンストラクタ.
    ///
    /// @param image テクスチャとして用いる画像データ, nullptr ならデータを読み込まない.
    /// @param width 読み込む画像の横の画素数.
    /// @param height 読み込む画像の縦の画素数.
    /// @param format 読み込む画像のフォーマット.
    /// @param type 読み込む画像のデータ型.
    /// @param internal テクスチャの内部フォーマット.
    /// @param wrap テクスチャのラッピングモード.
    /// @param swizzle true ならテクスチャの赤と青を入れ替える, デフォルトは true.
    ///
    GgColorTexture(
      const GLvoid* image,
      GLsizei width,
      GLsizei height,
      GLenum format = GL_RGB,
      GLenum type = GL_UNSIGNED_BYTE,
      GLenum internal = GL_RGB,
      GLenum wrap = GL_CLAMP_TO_EDGE,
      bool swizzle = true
    )
    {
      load(image, width, height, format, type, internal, wrap, swizzle);
    }

    ///
    /// TGA フォーマットの画像ファイルを読み込んでカラーのテクスチャを作成するコンストラクタ.
    ///
    /// @param name 読み込むファイル名.
    /// @param internal glTexImage2D() に指定するテクスチャの内部フォーマット, 0 なら外部フォーマットに合わせる.
    /// @param wrap テクスチャのラッピングモード, GL_TEXTURE_WRAP_S および GL_TEXTURE_WRAP_T に設定する値.
    ///
    GgColorTexture(
      const std::string& name,
      GLenum internal = 0,
      GLenum wrap = GL_CLAMP_TO_EDGE
    )
    {
      load(name, internal, wrap);
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgColorTexture()
    {
    }

    ///
    /// メモリ上のデータを読み込んでテクスチャを作成する.
    ///
    /// @param image テクスチャとして用いる画像データ, nullptr ならデータを読み込まない.
    /// @param width テクスチャの横の画素数.
    /// @param height テクスチャの縦の画素数.
    /// @param format 読み込む画像のフォーマット.
    /// @param type 読み込む画像のデータ型.
    /// @param internal glTexImage2D() に指定するテクスチャの内部フォーマット.
    /// @param wrap テクスチャのラッピングモード (GL_CLAMP_TO_EDGE, GL_CLAMP_TO_BORDER, GL_REPEAT, GL_MIRRORED_REPEAT).
    /// @param swizzle true ならテクスチャの赤と青を入れ替える, デフォルトは true.
    ///
    void load(
      const GLvoid* image,
      GLsizei width,
      GLsizei height,
      GLenum format = GL_RGB,
      GLenum type = GL_UNSIGNED_BYTE,
      GLenum internal = GL_RGB,
      GLenum wrap = GL_CLAMP_TO_EDGE,
      bool swizzle = true
    )
    {
      // テクスチャを作成する
      texture = std::make_shared<GgTexture>(image, width, height, format, type, internal, wrap, swizzle);
    }

    ///
    /// TGA フォーマットの画像ファイルを読み込んでカラーのテクスチャを作成する.
    ///
    /// @param name 読み込むファイル名.
    /// @param internal glTexImage2D() に指定するテクスチャの内部フォーマット, 0 ならファイルの画像フォーマットに合わせる.
    /// @param wrap テクスチャのラッピングモード (GL_CLAMP_TO_EDGE, GL_CLAMP_TO_BORDER, GL_REPEAT, GL_MIRRORED_REPEAT).
    ///
    void load(
      const std::string& name,
      GLenum internal = 0,
      GLenum wrap = GL_CLAMP_TO_EDGE
    );
  };

  ///
  /// 法線マップ.
  ///
  /// @note
  /// 高さマップ（グレイスケール画像）を読み込んで法線マップのテクスチャを作成する.
  ///
  class GgNormalTexture
  {
    // テクスチャ
    std::shared_ptr<GgTexture> texture;

  public:

    ///
    /// コンストラクタ.
    ///
    GgNormalTexture()
    {
    }

    ///
    /// メモリ上のデータから法線マップのテクスチャを作成するコンストラクタ.
    ///
    /// @param image テクスチャとして用いる画像データ, nullptr ならデータを読み込まない.
    /// @param width テクスチャとして用いる画像データの横幅.
    /// @param height テクスチャとして用いる画像データの高さ.
    /// @param format テクスチャとして用いる画像データのフォーマット (GL_RED, GL_RG, GL_RGB, GL_RGBA).
    /// @param nz 法線マップの z 成分の値.
    /// @param internal テクスチャの内部フォーマット.
    ///
    GgNormalTexture(
      const GLubyte* image,
      GLsizei width,
      GLsizei height,
      GLenum format = GL_RED,
      GLfloat nz = 1.0f,
      GLenum internal = GL_RGBA
    )
    {
      // 法線マップのテクスチャを作成する
      load(image, width, height, format, nz, internal);
    }

    ///
    /// ファイルからデータを読み込んで法線マップのテクスチャを作成するコンストラクタ.
    ///
    /// @param name 画像ファイル名.
    /// @param nz 法線マップの z 成分の値.
    /// @param internal テクスチャの内部フォーマット.
    ///
    GgNormalTexture(
      const std::string& name,
      GLfloat nz = 1.0f,
      GLenum internal = GL_RGBA
    )
    {
      // 法線マップのテクスチャを作成する
      load(name, nz, internal);
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgNormalTexture()
    {
    }

    ///
    /// メモリ上のデータから法線マップのテクスチャを作成する.
    ///
    /// @param hmap テクスチャとして用いる画像データ, nullptr ならデータを読み込まない.
    /// @param width テクスチャとして用いる画像データの横幅.
    /// @param height テクスチャとして用いる画像データの高さ.
    /// @param format テクスチャとして用いる画像データのフォーマット (GL_RED, GL_RG, GL_RGB, GL_RGBA).
    /// @param nz 法線マップの z 成分の値.
    /// @param internal テクスチャの内部フォーマット.
    ///
    void load(
      const GLubyte* hmap,
      GLsizei width,
      GLsizei height,
      GLenum format = GL_RED,
      GLfloat nz = 1.0f,
      GLenum internal = GL_RGBA
    )
    {
      // 法線マップ
      std::vector<GgVector> nmap;

      // 法線マップを作成する
      ggCreateNormalMap(hmap, width, height, format, nz, internal, nmap);

      // テクスチャを作成する
      texture = std::make_shared<GgTexture>(nmap.data(), width, height, GL_RGBA, GL_FLOAT, internal, GL_REPEAT);
    }

    ///
    /// TGA フォーマットの画像ファイルから高さマップ読み込んで法線マップのテクスチャを作成する.
    ///
    /// @param name 画像ファイル名 (1 チャネルの TGA 画像).
    /// @param nz 法線マップの z 成分の値.
    /// @param internal テクスチャの内部フォーマット.
    ///
    void load(
      const std::string& name,
      GLfloat nz = 1.0f,
      GLenum internal = GL_RGBA
    );
  };

  ///
  /// バッファオブジェクト.
  ///
  /// @note
  /// 頂点属性／頂点インデックス／ユニフォーム変数を格納するバッファオブジェクトの基底クラス.
  ///
  template <typename T>
  class GgBuffer
  {
    // ターゲット
    const GLenum target;

    // バッファオブジェクトのアライメントを考慮したデータの間隔
    const GLsizei stride;

    // データの数
    const GLsizei count;

    // バッファオブジェクト
    const GLuint buffer;

  public:

    ///
    /// コンストラクタ.
    ///
    /// @param target バッファオブジェクトのターゲット.
    /// @param data データが格納されている領域の先頭のポインタ (nullptr ならデータを転送しない).
    /// @param count データの数.
    /// @param stride データの間隔.
    /// @param usage バッファオブジェクトの使い方.
    ///
    GgBuffer<T>(
      GLenum target,
      const T* data,
      GLsizei stride,
      GLsizei count,
      GLenum usage
      ) :
      target{ target },
      stride{ stride },
      count{ count },
      buffer{ [] { GLuint buffer; glGenBuffers(1, &buffer); return buffer; } () }
    {
      // バッファオブジェクトのメモリを確保してデータを転送する
      glBindBuffer(target, buffer);
      glBufferData(target, getStride()* count, data, usage);
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgBuffer<T>()
    {
      // バッファオブジェクトを削除する
      glBindBuffer(target, 0);
      glDeleteBuffers(1, &buffer);
    }

    ///
    /// コピーコンストラクタは使用禁止.
    ///
    GgBuffer<T>(const GgBuffer<T>& o) = delete;

    ///
    /// 代入演算子は使用禁止.
    ///
    GgBuffer<T>& operator=(const GgBuffer<T>& o) = delete;

    ///
    /// バッファオブジェクトのターゲットを取り出す.
    ///
    /// @return このバッファオブジェクトのターゲット.
    ///
    const GLuint& getTarget() const
    {
      return target;
    }

    ///
    /// バッファオブジェクトのアライメントを考慮したデータの間隔を取り出す.
    ///
    /// @return このバッファオブジェクトのデータの間隔.
    ///
    GLsizeiptr getStride() const
    {
      return static_cast<GLsizeiptr>(stride);
    }

    ///
    /// バッファオブジェクトが保持するデータの数を取り出す.
    ///
    /// @return このバッファオブジェクトが保持するデータの数.
    ///
    const GLsizei& getCount() const
    {
      return count;
    }

    ///
    /// バッファオブジェクト名を取り出す.
    ///
    /// @return このバッファオブジェクト名.
    ///
    const GLuint& getBuffer() const
    {
      return buffer;
    }

    ///
    /// バッファオブジェクトを結合する.
    ///
    void bind() const
    {
      glBindBuffer(target, buffer);
    }

    ///
    /// バッファオブジェクトを解放する.
    ///
    void unbind() const
    {
      glBindBuffer(target, 0);
    }

    ///
    /// バッファオブジェクトをマップする.
    ///
    /// @return マップしたメモリの先頭のポインタ.
    ///
    void* map() const
    {
      glBindBuffer(target, buffer);
#if defined(GL_GLES_PROTOTYPES)
      return glMapBufferRange(target, 0, getStride() * count, GL_MAP_WRITE_BIT);
#else
      return glMapBuffer(target, GL_WRITE_ONLY);
#endif
    }

    ///
    /// バッファオブジェクトの指定した範囲をマップする.
    ///
    /// @param first マップする範囲のバッファオブジェクトの先頭からの位置.
    /// @param count マップするデータの数 (0 ならバッファオブジェクト全体).
    /// @return マップしたメモリの先頭のポインタ.
    ///
    void* map(GLint first, GLsizei count) const
    {
      // count が 0 なら全データをマップする
      if (count == 0) count = getCount();
      if (first + count > getCount()) count = getCount() - first;

      glBindBuffer(target, buffer);
      return glMapBufferRange(target, getStride() * first, getStride() * count, GL_MAP_WRITE_BIT);
    }

    ///
    /// バッファオブジェクトをアンマップする.
    ///
    void unmap() const
    {
      glUnmapBuffer(target);
    }

    ///
    /// すでに確保したバッファオブジェクトにデータを転送する.
    ///
    /// @param data 転送元のデータが格納されている領域の先頭のポインタ.
    /// @param first 転送先のバッファオブジェクトの先頭の要素番号.
    /// @param count 転送するデータの数 (0 ならバッファオブジェクト全体).
    ///
    void send(const T* data, GLint first, GLsizei count) const
    {
      // count が 0 なら全データを転送する
      if (count == 0) count = getCount();
      if (first + count > getCount()) count = getCount() - first;

      // データを既存のバッファオブジェクトに転送する
      glBindBuffer(target, buffer);
      glBufferSubData(target, getStride() * first, getStride() * count, data);
    }

    ///
    /// バッファオブジェクトのデータから抽出する.
    ///
    /// @param data 抽出先の領域の先頭のポインタ.
    /// @param first 抽出元のバッファオブジェクトの取り出すデータの領域の先頭の要素番号.
    /// @param count 抽出するデータの数 (0 ならバッファオブジェクト全体).
    ///
    void read(T* data, GLint first, GLsizei count) const
    {
      // count が 0 なら全データを抽出する
      if (count == 0) count = getCount();
      if (first + count > getCount()) count = getCount() - first;

      // データをバッファオブジェクトから抽出する
      glBindBuffer(target, buffer);
#if defined(GL_GLES_PROTOTYPES)
      const GLsizeiptr begin{ getStride() * first };
      const GLsizeiptr range{ getStride() * count };
      T* const source{ glMapBufferRange(target, begin, range, GL_MAP_READ_BIT) };
      std::copy(source, source + count, data);
      glUnmapBuffer(target);
#else
      glGetBufferSubData(target, getStride() * first, getStride() * count, data);
#endif
    }

    ///
    /// 別のバッファオブジェクトからデータを複写する.
    ///
    /// @param src_buffer 複写元のバッファオブジェクト名.
    /// @param src_first 複写元 (src_buffer) の先頭のデータの位置.
    /// @param dst_first 複写先 (getBuffer()) の先頭のデータの位置.
    /// @param count 複写するデータの数 (0 ならバッファオブジェクト全体).
    ///
    void copy(GLuint src_buffer, GLint src_first = 0, GLint dst_first = 0, GLsizei count = 0) const
    {
      // count が 0 なら全データを複写する
      if (count == 0) count = getCount();
      if (src_first + count > getCount()) count = getCount() - src_first;
      if (dst_first + count > getCount()) count = getCount() - dst_first;

      // データの間隔
      const GLsizeiptr stride{ getStride() };

      glBindBuffer(GL_COPY_READ_BUFFER, src_buffer);
      glBindBuffer(GL_COPY_WRITE_BUFFER, buffer);
      glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER,
        stride * src_first, stride * dst_first, stride * count);
      glBindBuffer(GL_COPY_WRITE_BUFFER, 0);
      glBindBuffer(GL_COPY_READ_BUFFER, 0);
    }
  };

  ///
  /// ユニフォームバッファオブジェクト.
  ///
  /// @note
  /// ユニフォーム変数を格納するバッファオブジェクトの基底クラス.
  ///
  template <typename T>
  class GgUniformBuffer
  {
    // ユニフォームバッファオブジェクト
    std::shared_ptr<GgBuffer<T>> uniform;

  public:

    ///
    /// コンストラクタ.
    ///
    GgUniformBuffer<T>()
    {
    }

    ///
    /// ユニフォームバッファオブジェクトのブロックごとにデータを転送するコンストラクタ.
    ///
    /// @param data データが格納されている領域の先頭のポインタ (nullptr ならデータを転送しない).
    /// @param count データの数.
    /// @param usage バッファオブジェクトの使い方.
    ///
    GgUniformBuffer<T>(const T* data, GLsizei count, GLenum usage = GL_STATIC_DRAW)
    {
      load(data, count, usage);
    }

    ///
    /// ユニフォームバッファオブジェクトの全ブロックに同じデータを格納するコンストラクタ.
    ///
    /// @param data 格納するデータ.
    /// @param count 格納する数.
    /// @param usage バッファオブジェクトの使い方.
    ///
    GgUniformBuffer<T>(const T& data, GLsizei count, GLenum usage = GL_STATIC_DRAW)
    {
      load(data, count, usage);
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgUniformBuffer<T>()
    {
    }

    ///
    /// ユニフォームバッファオブジェクトのターゲットを取り出す.
    ///
    /// @return このユニフォームバッファオブジェクトのターゲット.
    ///
    const GLuint& getTarget() const
    {
      return uniform->getTarget();
    }

    ///
    /// ユニフォームバッファオブジェクトのアライメントを考慮したデータの間隔を取り出す.
    ///
    /// @return このユニフォームバッファオブジェクトのデータの間隔.
    ///
    GLsizeiptr getStride() const
    {
      return uniform->getStride();
    }

    ///
    /// データの数を取り出す.
    ///
    /// @return このユニフォームバッファオブジェクトのデータの数.
    ///
    const GLsizei& getCount() const
    {
      return uniform->getCount();
    }

    ///
    /// ユニフォームバッファオブジェクト名を取り出す.
    ///
    /// @return このユニフォームバッファオブジェクト名.
    ///
    const GLuint& getBuffer() const
    {
      return uniform->getBuffer();
    }

    ///
    /// ユニフォームバッファオブジェクトを結合する.
    ///
    void bind() const
    {
      uniform->bind();
    }

    ///
    /// ユニフォームバッファオブジェクトを解放する.
    ///
    void unbind() const
    {
      uniform->unbind();
    }

    ///
    /// ユニフォームバッファオブジェクトをマップする.
    ///
    /// @return マップしたメモリの先頭のポインタ.
    ///
    void* map() const
    {
      return uniform->map();
    }

    ///
    /// ユニフォームバッファオブジェクトの指定した範囲をマップする.
    ///
    /// @param first マップする範囲のバッファオブジェクトの先頭からの位置.
    /// @param count マップするデータの数 (0 ならバッファオブジェクト全体).
    /// @return マップしたメモリの先頭のポインタ.
    ///
    void* map(GLint first, GLsizei count) const
    {
      return uniform->map(first, count);
    }

    ///
    /// バッファオブジェクトをアンマップする.
    ///
    void unmap() const
    {
      uniform->unmap();
    }

    ///
    /// ユニフォームバッファオブジェクトを確保してブロックごとにデータを転送する.
    ///
    /// @param data データが格納されている領域の先頭のポインタ (nullptr ならデータを転送しない).
    /// @param count データの数.
    /// @param usage バッファオブジェクトの使い方.
    ///
    void load(const T* data, GLsizei count, GLenum usage = GL_STATIC_DRAW)
    {
      // バッファオブジェクト上のデータの間隔
      const GLsizei stride{ (((static_cast<GLint>(sizeof(T)) - 1) / ggBufferAlignment) + 1) * ggBufferAlignment };

      // ユニフォームバッファオブジェクトを確保する
      uniform = std::make_shared<GgBuffer<T>>(GL_UNIFORM_BUFFER, nullptr, stride, count, usage);

      // 確保したユニフォームバッファオブジェクトにデータを転送する
      if (data) send(data, 0, sizeof(T), 0, count);
    }

    ///
    /// ユニフォームバッファオブジェクトを確保して全てのブロックに同じデータを格納する.
    ///
    /// @param data 格納するデータ.
    /// @param count 格納する数.
    /// @param usage バッファオブジェクトの使い方.
    ///
    void load(const T& data, GLsizei count, GLenum usage = GL_STATIC_DRAW)
    {
      // バッファオブジェクト上のデータの間隔
      const GLsizei stride{ (((static_cast<GLint>(sizeof(T)) - 1) / ggBufferAlignment) + 1) * ggBufferAlignment };

      // ユニフォームバッファオブジェクトを確保する
      uniform = std::make_shared<GgBuffer<T>>(GL_UNIFORM_BUFFER, nullptr, stride, count, usage);

      // 確保したユニフォームバッファオブジェクトにデータを転送する
      fill(&data, 0, sizeof(T), 0, count);
    }

    ///
    /// ユニフォームバッファオブジェクトを確保してユニフォームバッファオブジェクトのブロックごとのメンバを同じデータで埋める.
    ///
    /// @param data データが格納されている領域の先頭のポインタ.
    /// @param offset 格納先のメンバのブロックの先頭からのバイトオフセット.
    /// @param size 格納するデータの一個あたりのバイト数.
    /// @param first 格納先のバッファオブジェクトのブロックの先頭の番号.
    /// @param count 格納するデータの数.
    ///
    void send(
      const GLvoid* data,
      GLint offset = 0,
      GLsizei size = sizeof(T),
      GLint first = 0,
      GLsizei count = 0
    ) const
    {
      // count が 0 なら全データを転送する
      if (count == 0) count = getCount();
      if (first + count > getCount()) count = getCount() - first;

      // 転送元のデータの先頭
      const char* source{ reinterpret_cast<const char*>(data) };

      // ターゲット
      const GLuint target{ getTarget() };

      // データの間隔
      const GLsizeiptr stride{ getStride() };

      // first 番目のブロックから count 個の各ブロックの先頭から offset バイトの位置にデータを転送する
      bind();
      for (GLsizei i = 0; i < count; ++i)
      {
        glBufferSubData(target, stride * (first + i) + offset, size, source + size * i);
      }
    }

    ///
    /// ユニフォームバッファオブジェクトの全ブロックのメンバーを同じデータを格納する.
    ///
    /// @param data 格納するデータ.
    /// @param offset 格納先のメンバのブロックの先頭からのバイトオフセット.
    /// @param size 格納するデータの一個あたりのバイト数.
    /// @param first 格納先のバッファオブジェクトのブロックの先頭の番号.
    /// @param count 格納するデータの数.
    ///
    void fill(
      const GLvoid* data,
      GLint offset = 0,
      GLsizei size = sizeof(T),
      GLint first = 0,
      GLsizei count = 0
    ) const
    {
      // count が 0 なら全データを転送する
      if (count == 0) count = getCount();
      if (first + count > getCount()) count = getCount() - first;

      // ターゲット
      const GLuint target{ getTarget() };

      // データの間隔
      const GLsizeiptr stride{ getStride() };

      // first 番目のブロックから count 個の各ブロックの先頭から offset バイトの位置にデータを転送する
      bind();
      for (GLsizei i = 0; i < count; ++i)
      {
        glBufferSubData(target, stride * (first + i) + offset, size, data);
      }
    }

    ///
    /// ユニフォームバッファオブジェクトからデータを抽出する.
    ///
    /// @param data 抽出先の領域の先頭のポインタ.
    /// @param offset 抽出元のユニフォームバッファオブジェクトのメンバのブロックの先頭からのバイトオフセット.
    /// @param size 抽出するデータの一個あたりのバイト数.
    /// @param first 抽出元のユニフォームバッファオブジェクトのブロックの先頭の番号.
    /// @param count 抽出するデータの数 (0 ならユニフォームバッファオブジェクト全体).
    ///
    void read(
      GLvoid* data,
      GLint offset = 0,
      GLsizei size = sizeof(T),
      GLint first = 0,
      GLsizei count = 0
    ) const
    {
      // count が 0 なら全データを転送する
      if (count == 0) count = getCount();
      if (first + count > getCount()) count = getCount() - first;

      // 抽出先のデータの先頭
      char* const destination{ reinterpret_cast<char*>(data) };

      // ターゲット
      const GLuint target{ getTarget() };

      // データの間隔
      const GLsizeiptr stride{ getStride() };

      // データをユニフォームバッファオブジェクトから抽出する
      bind();
#if defined(GL_GLES_PROTOTYPES)
      const char* const source{ glMapBufferRange(target, stride * first, stride * count, GL_MAP_READ_BIT) };
      for (GLsizei i = 0; i < count; ++i)
      {
        const char* const begin{ source + stride * i + offset };
        const char* const end{ begin + size };
        std::copy(begin, end, destination + sizeof(T) * i);
      }
      glUnmapBuffer(target);
#else
      for (GLsizei i = 0; i < count; ++i)
      {
        glGetBufferSubData(target, stride * (first + i) + offset, size, destination + sizeof(T) * i);
      }
#endif
    }

    ///
    /// 別のバッファオブジェクトからデータを複写する.
    ///
    /// @param src_buffer 複写元のバッファオブジェクト名.
    /// @param src_first 複写元 (buffer) の先頭のデータの位置.
    /// @param dst_first 複写先 (getBuffer()) の先頭のデータの位置.
    /// @param count 複写するデータの数 (0 ならバッファオブジェクト全体).
    ///
    void copy(
      GLuint src_buffer,
      GLint src_first = 0,
      GLint dst_first = 0,
      GLsizei count = 0
    ) const
    {
      // count が 0 なら全データを複写する
      if (count == 0) count = getCount();
      if (src_first + count > getCount()) count = getCount() - src_first;
      if (dst_first + count > getCount()) count = getCount() - dst_first;

      // データの間隔
      const GLsizeiptr stride{ getStride() };

      // ユニフォームバッファオブジェクトではブロックごとに転送する
      glBindBuffer(GL_COPY_READ_BUFFER, src_buffer);
      glBindBuffer(GL_COPY_WRITE_BUFFER, getBuffer());
      for (GLsizei i = 0; i < count; ++i)
      {
        glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER,
          stride * (src_first + i), stride * (dst_first + i), sizeof(T));
      }
      glBindBuffer(GL_COPY_WRITE_BUFFER, 0);
      glBindBuffer(GL_COPY_READ_BUFFER, 0);
    }
  };

  ///
  /// 頂点配列クラス.
  ///
  class GgVertexArray
  {
    // 頂点配列オブジェクト
    const GLuint vao;

  public:

    ///
    /// コンストラクタ.
    ///
    /// @param mode 基本図形の種類.
    ///
    GgVertexArray(GLenum mode = 0) :
      vao{ [] { GLuint vao; glGenVertexArrays(1, &vao); return vao; } () }
    {
      glBindVertexArray(vao);
    }

    ///
    /// コピーコンストラクタは使用禁止.
    ///
    GgVertexArray(const GgVertexArray& o) = delete;

    ///
    /// デストラクタ.
    ///
    virtual ~GgVertexArray()
    {
      glBindVertexArray(0);
      glDeleteVertexArrays(1, &vao);
    }

    ///
    /// 代入演算子は使用禁止.
    ///
    GgVertexArray& operator=(const GgVertexArray& o) = delete;

    ///
    /// 頂点配列オブジェクト名を取り出す.
    ///
    /// @return 頂点配列オブジェクト名.
    ///
    const GLuint& get() const
    {
      return vao;
    }

    ///
    /// 頂点配列オブジェクトを結合する.
    ///
    void bind() const
    {
      glBindVertexArray(vao);
    }
  };

  ///
  /// 形状データの基底クラス.
  ///
  /// @note
  /// 形状データのクラスはこのクラスを派生して作る.
  /// 基本図形の種類と頂点配列オブジェクトを保持する.
  ///
  class GgShape
  {
    // 頂点配列オブジェクト
    std::shared_ptr<GgVertexArray> object;

    // 基本図形の種類
    GLenum mode;

  public:

    ///
    /// コンストラクタ.
    ///
    /// @param mode 基本図形の種類.
    ///
    GgShape(GLenum mode = 0) :
      object{ std::make_shared<GgVertexArray>() },
      mode{ mode }
    {
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgShape()
    {
    }

    ///
    /// 頂点配列オブジェクトが有効かどうか調べる.
    ///
    /// @return 頂点配列オブジェクトが有効なら true
    ///
    virtual explicit operator bool() const noexcept
    {
      return object.get() != nullptr;
    }

    ///
    /// 頂点配列オブジェクトが有効かどうかの結果を反転する.
    ///
    /// @return 頂点配列オブジェクトが有効なら false, 無効なら true.
    ///
    virtual bool operator!() const noexcept
    {
      return !static_cast<bool>(*this);
    }

    ///
    /// 頂点配列オブジェクト名を取り出す.
    ///
    /// @return 頂点配列オブジェクト名.
    ///
    const GLuint& get() const
    {
      return object->get();
    }

    ///
    /// 基本図形の設定.
    ///
    /// @param mode 基本図形の種類.
    ///
    void setMode(GLenum mode)
    {
      this->mode = mode;
    }

    ///
    /// 基本図形の検査.
    ///
    /// @return この頂点配列オブジェクトの基本図形の種類.
    ///
    const GLenum& getMode() const
    {
      return this->mode;
    }

    ///
    /// 図形の描画, 派生クラスでこの手続きをオーバーライドする.
    ///
    /// @param first 描画する最初のアイテム.
    /// @param count 描画するアイテムの数, 0 なら全部のアイテムを描画する.
    ///
    virtual void draw(GLint first = 0, GLsizei count = 0) const
    {
      object->bind();
    }
  };

  ///
  /// 点.
  ///
  class GgPoints
    : public GgShape
  {
    // 頂点バッファオブジェクト
    std::shared_ptr<GgBuffer<GgVector>> position;

  public:

    ///
    /// コンストラクタ.
    ///
    GgPoints(GLenum mode = GL_POINTS) :
      GgShape(mode)
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param pos この図形の頂点の位置のデータの配列 (nullptr ならデータを転送しない).
    /// @param countv 頂点数.
    /// @param mode 描画する基本図形の種類.
    /// @param usage バッファオブジェクトの使い方.
    ///
    GgPoints(
      const GgVector* pos,
      GLsizei countv,
      GLenum mode = GL_POINTS,
      GLenum usage = GL_STATIC_DRAW
    ) :
      GgPoints(mode)
    {
      load(pos, countv, usage);
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgPoints()
    {
    }

    ///
    /// バッファが有効かどうか調べる.
    ///
    /// @return バッファが有効なら true
    ///
    explicit operator bool() const noexcept
    {
      return position.get() != nullptr;
    }

    ///
    /// バッファが有効かどうかの結果を反転する.
    ///
    /// @return バッファが有効なら false, 無効なら true.
    ///
    bool operator!() const noexcept
    {
      return !static_cast<bool>(*this);
    }

    ///
    /// データの数を取り出す.
    ///
    /// @return この図形の頂点の位置データの数 (頂点数).
    ///
    const GLsizei& getCount() const
    {
      return position->getCount();
    }

    ///
    /// 頂点の位置データを格納した頂点バッファオブジェクト名を取り出す.
    ///
    /// @return この図形の頂点の位置データを格納した頂点バッファオブジェクト名.
    ///
    const GLuint& getBuffer() const
    {
      return position->getBuffer();
    }

    ///
    /// 既存のバッファオブジェクトに頂点の位置データを転送する.
    ///
    /// @param pos 転送元の頂点の位置データが格納されている領域の先頭のポインタ.
    /// @param first 転送先のバッファオブジェクトの先頭の要素番号.
    /// @param count 転送する頂点の位置データの数 (0 ならバッファオブジェクト全体).
    ///
    void send(const GgVector* pos, GLint first = 0, GLsizei count = 0) const
    {
      position->send(pos, first, count);
    }

    ///
    /// バッファオブジェクトを確保して頂点の位置データを格納する.
    ///
    /// @param pos 頂点の位置データが格納されている領域の先頭のポインタ.
    /// @param count 頂点のデータの数 (頂点数).
    /// @param usage バッファオブジェクトの使い方.
    ///
    void load(const GgVector* pos, GLsizei count, GLenum usage = GL_STATIC_DRAW);

    ///
    /// 点の描画.
    ///
    /// @param first 描画を開始する最初の点の番号.
    /// @param count 描画する点の数, 0 なら全部の点を描く.
    ///
    virtual void draw(GLint first = 0, GLsizei count = 0) const;
  };

  ///
  /// 三角形の頂点データ.
  ///
  struct GgVertex
  {
    /// 位置.
    GgVector position;

    /// 法線.
    GgVector normal;

    ///
    /// コンストラクタ.
    ///
    GgVertex()
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param pos GgVector 型の位置データ.
    /// @param norm GgVector 型の法線データ.
    ///
    GgVertex(const GgVector& pos, const GgVector& norm) :
      position(pos),
      normal(norm)
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param px GgVector 型の位置データの x 成分.
    /// @param py GgVector 型の位置データの y 成分.
    /// @param pz GgVector 型の位置データの z 成分.
    /// @param nx GgVector 型の法線データの x 成分.
    /// @param ny GgVector 型の法線データの y 成分.
    /// @param nz GgVector 型の法線データの z 成分.
    ///
    GgVertex(
      GLfloat px, GLfloat py, GLfloat pz,
      GLfloat nx, GLfloat ny, GLfloat nz
    ) :
      position{ px, py, pz, 1.0f },
      normal{ nx, ny, nz, 0.0f }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param pos 3 要素の GLfloat 型の位置データのポインタ.
    /// @param norm 3 要素の GLfloat 型の法線データのポインタ.
    ///
    GgVertex(const GLfloat* pos, const GLfloat* norm) :
      GgVertex(pos[0], pos[1], pos[2], norm[0], norm[1], norm[2])
    {
    }
  };

  ///
  /// 三角形で表した形状データ (Arrays 形式).
  ///
  class GgTriangles
    : public GgShape
  {
    // 頂点属性
    std::shared_ptr<GgBuffer<GgVertex>> vertex;

  public:

    ///
    /// コンストラクタ.
    ///
    /// @param mode 描画する基本図形の種類.
    ///
    GgTriangles(GLenum mode = GL_TRIANGLES) :
      GgShape(mode)
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param vert この図形の頂点属性の配列 (nullptr ならデータを転送しない).
    /// @param count 頂点数.
    /// @param mode 描画する基本図形の種類.
    /// @param usage バッファオブジェクトの使い方.
    ///
    GgTriangles(
      const GgVertex* vert,
      GLsizei count,
      GLenum mode = GL_TRIANGLES,
      GLenum usage = GL_STATIC_DRAW
    ) :
      GgTriangles(mode)
    {
      load(vert, count, usage);
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgTriangles()
    {
    }

    ///
    /// データの数を取り出す.
    ///
    /// @return この図形の頂点属性の数 (頂点数).
    ///
    const GLsizei& getCount() const
    {
      return vertex->getCount();
    }

    ///
    /// 頂点属性を格納した頂点バッファオブジェクト名を取り出す.
    ///
    /// @return この図形の頂点属性を格納した頂点バッファオブジェクト名.
    ///
    const GLuint& getBuffer() const
    {
      return vertex->getBuffer();
    }

    ///
    /// 既存のバッファオブジェクトに頂点属性を転送する.
    ///
    /// @param vert 転送元の頂点属性が格納されている領域の先頭のポインタ.
    /// @param first 転送先のバッファオブジェクトの先頭の要素番号.
    /// @param count 転送する頂点の位置データの数 (0 ならバッファオブジェクト全体).
    ///
    void send(const GgVertex* vert, GLint first = 0, GLsizei count = 0) const
    {
      vertex->send(vert, first, count);
    }

    ///
    /// バッファオブジェクトを確保して頂点属性を格納する.
    ///
    /// @param vert 頂点属性が格納されている領域の先頭のポインタ.
    /// @param count 頂点のデータの数 (頂点数).
    /// @param usage バッファオブジェクトの使い方.
    ///
    void load(const GgVertex* vert, GLsizei count, GLenum usage = GL_STATIC_DRAW);

    ///
    /// 三角形の描画.
    ///
    /// @param first 描画を開始する最初の三角形番号.
    /// @param count 描画する三角形数, 0 なら全部の三角形を描く.
    ///
    virtual void draw(GLint first = 0, GLsizei count = 0) const;
  };

  ///
  /// 三角形で表した形状データ (Elements 形式).
  ///
  class GgElements
    : public GgTriangles
  {
    // インデックスを格納する頂点バッファオブジェクト
    std::shared_ptr<GgBuffer<GLuint>> index;

  public:

    ///
    /// コンストラクタ.
    ///
    /// @param mode 描画する基本図形の種類.
    ///
    GgElements(GLenum mode = GL_TRIANGLES) :
      GgTriangles(mode)
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param vert この図形の頂点属性の配列 (nullptr ならデータを転送しない).
    /// @param countv 頂点数.
    /// @param face 三角形の頂点インデックス.
    /// @param countf 三角形の頂点数.
    /// @param mode 描画する基本図形の種類.
    /// @param usage バッファオブジェクトの使い方.
    ///
    GgElements(
      const GgVertex* vert,
      GLsizei countv,
      const GLuint* face,
      GLsizei countf,
      GLenum mode = GL_TRIANGLES,
      GLenum usage = GL_STATIC_DRAW
    ) :
      GgElements(mode)
    {
      load(vert, countv, face, countf, usage);
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgElements()
    {
    }

    ///
    /// データの数を取り出す.
    ///
    /// @return この図形の三角形数.
    const GLsizei& getIndexCount() const
    {
      return index->getCount();
    }

    ///
    /// 三角形の頂点インデックスデータを格納した頂点バッファオブジェクト名を取り出す.
    ///
    /// @return この図形の三角形の頂点インデックスデータを格納した頂点バッファオブジェクト名.
    ///
    const GLuint& getIndexBuffer() const
    {
      return index->getBuffer();
    }

    ///
    /// 既存のバッファオブジェクトに頂点属性と三角形の頂点インデックスデータを転送する.
    ///
    /// @param vert 頂点属性が格納されている領域の先頭のポインタ.
    /// @param firstv 頂点属性の転送先のバッファオブジェクトの先頭の要素番号.
    /// @param countv 頂点のデータの数 (頂点数).
    /// @param face 三角形の頂点インデックスデータ.
    /// @param firstf インデックスの転送先のバッファオブジェクトの先頭の要素番号.
    /// @param countf 三角形の頂点数.
    ///
    void send(
      const GgVertex* vert,
      GLuint firstv,
      GLsizei countv,
      const GLuint* face = nullptr,
      GLuint firstf = 0,
      GLsizei countf = 0
    ) const
    {
      GgTriangles::send(vert, firstv, countv);
      if (face != nullptr && countf > 0) index->send(face, firstf, countf);
    }

    ///
    /// バッファオブジェクトを確保して頂点属性と三角形の頂点インデックスデータを格納する.
    ///
    /// @param vert 頂点属性が格納されている領域の先頭のポインタ.
    /// @param countv 頂点のデータの数 (頂点数).
    /// @param face 三角形の頂点インデックスデータ.
    /// @param countf 三角形の頂点数.
    /// @param usage バッファオブジェクトの使い方.
    ///
    void load(
      const GgVertex* vert,
      GLsizei countv,
      const GLuint* face,
      GLsizei countf,
      GLenum usage = GL_STATIC_DRAW
    )
    {
      // 頂点バッファオブジェクトを作成する
      GgTriangles::load(vert, countv, usage);

      // インデックスの頂点バッファオブジェクトを作成する
      index = std::make_shared<GgBuffer<GLuint>>(GL_ELEMENT_ARRAY_BUFFER, face, static_cast<GLsizei>(sizeof(GLuint)), countf, usage);
    }

    ///
    /// インデックスを使った三角形の描画.
    ///
    /// @param first 描画を開始する最初の三角形番号.
    /// @param count 描画する三角形数, 0 なら全部の三角形を描く.
    ///
    virtual void draw(GLint first = 0, GLsizei count = 0) const;
  };

  ///
  /// 点群を立方体状に生成する.
  ///
  /// @param countv 生成する点の数.
  /// @param length 点群を生成する立方体の一辺の長さ.
  /// @param cx 点群の中心の x 座標.
  /// @param cy 点群の中心の y 座標.
  /// @param cz 点群の中心の z 座標.
  /// @return GgPoints 型の ポインタ.
  ///
  extern std::shared_ptr<GgPoints> ggPointsCube(
    GLsizei countv,
    GLfloat length = 1.0f,
    GLfloat cx = 0.0f,
    GLfloat cy = 0.0f,
    GLfloat cz = 0.0f
  );

  ///
  /// 点群を球状に生成する.
  ///
  /// @param countv 生成する点の数.
  /// @param radius 点群を生成する半径.
  /// @param cx 点群の中心の x 座標.
  /// @param cy 点群の中心の y 座標.
  /// @param cz 点群の中心の z 座標.
  /// @return GgPoints 型のポインタ.
  ///
  extern std::shared_ptr<GgPoints> ggPointsSphere(
    GLsizei countv,
    GLfloat radius = 0.5f,
    GLfloat cx = 0.0f,
    GLfloat cy = 0.0f,
    GLfloat cz = 0.0f
  );

  ///
  /// 矩形状に 2 枚の三角形を生成する.
  ///
  /// @param width 矩形の横幅.
  /// @param height 矩形の高さ.
  /// @return GgTriangles 型のポインタ.
  ///
  extern std::shared_ptr<GgTriangles> ggRectangle(
    GLfloat width = 1.0f,
    GLfloat height = 1.0f
  );

  ///
  /// 楕円状に三角形を生成する.
  ///
  /// @param width 楕円の横幅.
  /// @param height 楕円の高さ.
  /// @param slices 楕円の分割数.
  /// @return GgTriangles 型のポインタ.
  ///
  extern std::shared_ptr<GgTriangles> ggEllipse(
    GLfloat width = 1.0f,
    GLfloat height = 1.0f,
    GLuint slices = 16
  );

  ///
  /// Wavefront OBJ ファイルを読み込む (Arrays 形式)
  ///
  /// @param name ファイル名.
  /// @param normalize true なら大きさを正規化.
  /// @return GgTriangles 型のポインタ.
  ///
  /// @note
  /// 三角形分割された Wavefront OBJ ファイルを読み込んで
  /// GgArrays 形式の三角形データを生成する.
  ///
  extern std::shared_ptr<GgTriangles> ggArraysObj(
    const std::string& name,
    bool normalize = false
  );

  ///
  /// Wavefront OBJ ファイル を読み込む (Elements 形式).
  ///
  /// @param name ファイル名.
  /// @param normalize true なら大きさを正規化.
  /// @return GgElements 型のポインタ.
  ///
  /// @note
  /// 三角形分割された Wavefront OBJ ファイル を読み込んで
  /// GgElements 形式の三角形データを生成する.
  ///
  extern std::shared_ptr<GgElements> ggElementsObj(
    const std::string& name,
    bool normalize = false
  );

  ///
  /// メッシュ形状を作成する (Elements 形式).
  ///
  /// @param slices メッシュの横方向の分割数.
  /// @param stacks メッシュの縦方向の分割数.
  /// @param pos メッシュの頂点の位置.
  /// @param norm メッシュの頂点の法線, nullptr なら頂点の位置から算出する.
  /// @return GgElements 型のポインタ.
  ///
  /// @note
  /// メッシュ状に GgElements 形式の三角形データを生成する.
  ///
  extern std::shared_ptr<GgElements> ggElementsMesh(
    GLuint slices,
    GLuint stacks,
    const GLfloat(*pos)[3],
    const GLfloat(*norm)[3] = nullptr
  );

  /// 球状に三角形データを生成する (Elements 形式).
  ///
  /// @param radius 球の半径.
  /// @param slices 球の経度方向の分割数.
  /// @param stacks 球の緯度方向の分割数.
  /// @return GgElements 型のポインタ.
  ///
  /// @note
  /// 球状に GgElements 形式の三角形データを生成する.
  ///
  extern std::shared_ptr<GgElements> ggElementsSphere(
    GLfloat radius = 1.0f,
    int slices = 16,
    int stacks = 8
  );

  ///
  /// シェーダの基底クラス.
  ///
  /// @note
  /// シェーダのクラスはこのクラスを派生して作る.
  ///
  class GgShader
  {
    // プログラム名
    const GLuint program;

  public:

    ///
    /// コンストラクタ.
    ///
    /// @param vert バーテックスシェーダのソースファイル名.
    /// @param frag フラグメントシェーダのソースファイル名 (空文字列なら不使用).
    /// @param geom ジオメトリシェーダのソースファイル名 (空文字列なら不使用).
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト.
    ///
    GgShader(
      const std::string& vert,
      const std::string& frag = "",
      const std::string& geom = "",
      int nvarying = 0,
      const char* const* varyings = nullptr
    ) :
      program(ggLoadShader(vert, frag, geom, nvarying, varyings))
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param files バーテックスシェーダのソースファイル名の配列.
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
    ///
    GgShader(
      const std::array<std::string, 3>& files,
      int nvarying = 0,
      const char* const* varyings = nullptr
    ) :
      GgShader(files[0], files[1], files[2], nvarying, varyings)
    {
    }

    ///
    /// コピーコンストラクタは使用禁止.
    ///
    GgShader(const GgShader& o) = delete;

    ///
    /// デストラクタ.
    ///
    virtual ~GgShader()
    {
      // 参照しているオブジェクトが一つだけならシェーダを削除する
      glUseProgram(0);
      glDeleteProgram(program);
    }

    ///
    /// 代入演算子は使用禁止.
    ///
    GgShader& operator=(const GgShader& o) = delete;

    ///
    /// シェーダプログラムの使用を開始する.
    ///
    void use() const
    {
      glUseProgram(program);
    }

    ///
    /// シェーダプログラムの使用を終了する.
    ///
    void unuse() const
    {
      glUseProgram(0);
    }

    ///
    /// シェーダのプログラム名を得る.
    ///
    /// @return シェーダのプログラム名.
    ///
    GLuint get() const
    {
      return program;
    }
  };

  ///
  /// 点のシェーダ.
  ///
  class GgPointShader
  {
    // シェーダー
    std::shared_ptr<GgShader> shader;

    // 投影変換行列の uniform 変数の場所
    GLint mpLoc;

    // モデルビュー変換行列の uniform 変数の場所
    GLint mvLoc;

  public:

    ///
    /// コンストラクタ.
    ///
    GgPointShader() :
      mpLoc{ -1 },
      mvLoc{ -1 }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param vert バーテックスシェーダのソースファイル名.
    /// @param frag フラグメントシェーダのソースファイル名 (空文字列なら不使用).
    /// @param geom ジオメトリシェーダのソースファイル名 (空文字列なら不使用).
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト.
    ///
    GgPointShader(
      const std::string& vert,
      const std::string& frag = "",
      const std::string& geom = "",
      GLint nvarying = 0,
      const char* const* varyings = nullptr
    ) :
      GgPointShader()
    {
      load(vert, frag, geom, nvarying, varyings);
    }

    ///
    /// コンストラクタ.
    ///
    /// @param files バーテックスシェーダのソースファイル名の配列.
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
    ///
    GgPointShader(
      const std::array<std::string, 3>& files,
      int nvarying = 0,
      const char* const* varyings = nullptr
    ) :
      GgPointShader(files[0], files[1], files[2], nvarying, varyings)
    {
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgPointShader()
    {
    }

    ///
    /// シェーダのソースファイルを読み込む.
    ///
    /// @param vert バーテックスシェーダのソースファイル名.
    /// @param frag フラグメントシェーダのソースファイル名 (空文字列なら不使用).
    /// @param geom ジオメトリシェーダのソースファイル名 (空文字列なら不使用).
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト.
    ///
    /// @return プログラムオブジェクトが作成できれば true.
    bool load(
      const std::string& vert,
      const std::string& frag = "",
      const std::string& geom = "",
      GLint nvarying = 0,
      const char* const* varyings = nullptr
    )
    {
      // シェーダを作成する
      shader = std::make_shared<GgShader>(vert, frag, geom, nvarying, varyings);

      // プログラム名を取り出す
      const GLuint program(shader->get());

      // プログラムオブジェクトが作成できていなければ戻る
      if (program == 0) return false;

      // 変換行列の uniform 変数の場所
      mpLoc = glGetUniformLocation(program, "mp");
      mvLoc = glGetUniformLocation(program, "mv");

      // プログラムオブジェクトの作成に成功した
      return true;
    }

    ///
    /// シェーダのソースファイルを読み込んでプログラムオブジェクトを作成する.
    ///
    /// @param files バーテックスシェーダのソースファイル名の配列.
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
    /// @return プログラムオブジェクトの作成に成功したら true.
    ///
    bool load(
      const std::array<std::string, 3>& files,
      GLint nvarying = 0,
      const char* const* varyings = nullptr
    )
    {
      return load(files[0], files[1], files[2], nvarying, varyings);
    }

    ///
    /// 投影変換行列を設定する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    ///
    virtual void loadProjectionMatrix(const GLfloat* mp) const
    {
      glUniformMatrix4fv(mpLoc, 1, GL_FALSE, mp);
    }

    ///
    /// 投影変換行列を設定する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    ///
    virtual void loadProjectionMatrix(const GgMatrix& mp) const
    {
      loadProjectionMatrix(mp.get());
    }

    ///
    /// モデルビュー変換行列を設定する.
    ///
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    ///
    virtual void loadModelviewMatrix(const GLfloat* mv) const
    {
      glUniformMatrix4fv(mvLoc, 1, GL_FALSE, mv);
    }

    ///
    /// モデルビュー変換行列を設定する.
    ///
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    ///
    virtual void loadModelviewMatrix(const GgMatrix& mv) const
    {
      loadModelviewMatrix(mv.get());
    }

    ///
    /// 投影変換行列とモデルビュー変換行列を設定する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    ///
    virtual void loadMatrix(const GLfloat* mp, const GLfloat* mv) const
    {
      loadProjectionMatrix(mp);
      loadModelviewMatrix(mv);
    }

    ///
    /// 投影変換行列とモデルビュー変換行列を設定する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    ///
    virtual void loadMatrix(const GgMatrix& mp, const GgMatrix& mv) const
    {
      loadMatrix(mp.get(), mv.get());
    }

    ///
    /// シェーダプログラムの使用を開始する.
    ///
    virtual void use() const
    {
      shader->use();
    }

    ///
    /// 投影変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    ///
    void use(const GLfloat* mp) const
    {
      use();
      loadProjectionMatrix(mp);
    }

    ///
    /// 投影変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    ///
    void use(const GgMatrix& mp) const
    {
      use(mp.get());
    }

    ///
    /// 投影変換行列とモデルビューを設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    ///
    void use(const GLfloat* mp, const GLfloat* mv) const
    {
      use(mp);
      loadModelviewMatrix(mv);
    }

    ///
    /// 投影変換行列とモデルビューを設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    ///
    void use(const GgMatrix& mp, const GgMatrix& mv) const
    {
      use(mp.get(), mv.get());
    }

    ///
    /// シェーダプログラムの使用を終了する.
    ///
    void unuse() const
    {
      shader->unuse();
    }

    ///
    /// シェーダのプログラム名を得る.
    ///
    /// @return シェーダのプログラム名.
    ///
    GLuint get() const
    {
      return shader->get();
    }
  };

  ///
  /// 三角形に単純な陰影付けを行うシェーダ.
  ///
  class GgSimpleShader
    : public GgPointShader
  {
    // 材質データの uniform block のインデックス
    GLint materialIndex;

    // 光源データの uniform block のインデックス
    GLint lightIndex;

    // モデルビュー変換の法線変換行列の uniform 変数の場所
    GLint mnLoc;

  public:

    ///
    /// コンストラクタ.
    ///
    GgSimpleShader() :
      GgPointShader(),
      materialIndex{ -1 },
      lightIndex{ -1 },
      mnLoc{ -1 }
    {
    }

    ///
    /// コンストラクタ.
    ///
    /// @param vert バーテックスシェーダのソースファイル名.
    /// @param frag フラグメントシェーダのソースファイル名 (空文字列なら不使用).
    /// @param geom ジオメトリシェーダのソースファイル名 (空文字列なら不使用).
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト.
    ///
    GgSimpleShader(
      const std::string& vert,
      const std::string& frag = "",
      const std::string& geom = "",
      GLint nvarying = 0,
      const char* const* varyings = nullptr
    )
    {
      load(vert, frag, geom, nvarying, varyings);
    }

    ///
    /// コンストラクタ.
    ///
    /// @param files バーテックスシェーダのソースファイル名の配列.
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
    ///
    GgSimpleShader(
      const std::array<std::string, 3>& files,
      GLint nvarying = 0,
      const char* const* varyings = nullptr
    ) :
      GgSimpleShader(files[0], files[1], files[2], nvarying, varyings)
    {
    }

    ///
    /// コピーコンストラクタ.
    ///
    GgSimpleShader(const GgSimpleShader& o) :
      GgPointShader(o),
      materialIndex{ o.materialIndex },
      lightIndex{ o.lightIndex },
      mnLoc{ o.mnLoc }
    {
    }

    ///
    /// デストラクタ.
    ///
    virtual ~GgSimpleShader()
    {
    }

    ///
    /// 代入演算子.
    ///
    GgSimpleShader& operator=(const GgSimpleShader& o)
    {
      if (&o != this)
      {
        GgPointShader::operator=(o);
        materialIndex = o.materialIndex;
        lightIndex = o.lightIndex;
        mnLoc = o.mnLoc;
      }

      return *this;
    }

    ///
    /// シェーダのソースプログラムの文字列からプログラムオブジェクトを作成する.
    ///
    /// @param vert バーテックスシェーダのソースプログラムの文字列.
    /// @param frag フラグメントシェーダのソースプログラムの文字列（空文字列なら不使用）.
    /// @param geom ジオメトリシェーダのソースプログラムの文字列（空文字列なら不使用）.
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
    /// @return プログラムオブジェクトの作成に成功したら true.
    ///
    bool load(
      const std::string& vert,
      const std::string& frag = "",
      const std::string& geom = "",
      GLint nvarying = 0,
      const char* const* varyings = nullptr
    );

    ///
    /// シェーダのソースファイルを読み込んでプログラムオブジェクトを作成する.
    ///
    /// @param files バーテックスシェーダのソースファイル名の配列.
    /// @param nvarying フィードバックする varying 変数の数 (0 なら不使用).
    /// @param varyings フィードバックする varying 変数のリスト (nullptr なら不使用).
    /// @return プログラムオブジェクトの作成に成功したら true.
    ///
    bool load(
      const std::array<std::string, 3>& files,
      GLint nvarying = 0,
      const char* const* varyings = nullptr
    )
    {
      return load(files[0], files[1], files[2], nvarying, varyings);
    }

    ///
    /// モデルビュー変換行列と法線変換行列を設定する.
    ///
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    /// @param mn GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列の法線変換行列.
    ///
    virtual void loadModelviewMatrix(const GLfloat* mv, const GLfloat* mn) const
    {
      GgPointShader::loadModelviewMatrix(mv);
      glUniformMatrix4fv(mnLoc, 1, GL_FALSE, mn);
    }

    ///
    /// モデルビュー変換行列と法線変換行列を設定する.
    ///
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    /// @param mn GgMatrix 型のモデルビュー変換行列の法線変換行列.
    ///
    virtual void loadModelviewMatrix(const GgMatrix& mv, const GgMatrix& mn) const
    {
      loadModelviewMatrix(mv.get(), mn.get());
    }

    ///
    /// モデルビュー変換行列とそれから求めた法線変換行列を設定する.
    ///
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    ///
    virtual void loadModelviewMatrix(const GLfloat* mv) const
    {
      loadModelviewMatrix(mv, GgMatrix(mv).normal().get());
    }

    ///
    /// モデルビュー変換行列とそれから求めた法線変換行列を設定する.
    ///
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    ///
    virtual void loadModelviewMatrix(const GgMatrix& mv) const
    {
      loadModelviewMatrix(mv.get());
    }

    ///
    /// 投影変換行列とモデルビュー変換行列と法線変換行列を設定する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    /// @param mn GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列の法線変換行列.
    ///
    virtual void loadMatrix(const GLfloat* mp, const GLfloat* mv, const GLfloat* mn) const
    {
      GgPointShader::loadMatrix(mp, mv);
      glUniformMatrix4fv(mnLoc, 1, GL_FALSE, mn);
    }

    ///
    /// 投影変換行列とモデルビュー変換行列と法線変換行列を設定する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    /// @param mn GgMatrix 型のモデルビュー変換行列の法線変換行列.
    ///
    virtual void loadMatrix(const GgMatrix& mp, const GgMatrix& mv, const GgMatrix& mn) const
    {
      loadMatrix(mp.get(), mv.get(), mn.get());
    }

    ///
    /// 投影変換行列とモデルビュー変換行列を設定しモデルビュー変換行列から求めた法線変換行列を設定する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    ///
    virtual void loadMatrix(const GLfloat* mp, const GLfloat* mv) const
    {
      loadMatrix(mp, mv, GgMatrix(mv).normal());
    }

    ///
    /// 投影変換行列とモデルビュー変換行列を設定しモデルビュー変換行列から求めた法線変換行列を設定する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    ///
    virtual void loadMatrix(const GgMatrix& mp, const GgMatrix& mv) const
    {
      loadMatrix(mp, mv, mv.normal());
    }

    ///
    /// 三角形に単純な陰影付けを行うシェーダが参照する光源データ.
    ///
    struct Light
    {
      GgVector ambient;   ///< 光源強度の環境光成分.
      GgVector diffuse;   ///< 光源強度の拡散反射光成分.
      GgVector specular;  ///< 光源強度の鏡面反射光成分.
      GgVector position;  ///< 光源の位置.
    };

    ///
    /// 三角形に単純な陰影付けを行うシェーダが参照する光源データのユニフォームバッファオブジェクト.
    ///
    class LightBuffer
      : public GgUniformBuffer<Light>
    {
    public:

      ///
      /// デフォルトコンストラクタ.
      ///
      /// @param light GgSimpleShader::Light 型の光源データのポインタ.
      /// @param count バッファ中の GgSimpleShader::Light 型の光源データの数.
      /// @param usage バッファの使い方のパターン, glBufferData() の第 4 引数の usage に渡される.
      ///
      LightBuffer(
        const Light* light = nullptr,
        GLsizei count = 1,
        GLenum usage = GL_STATIC_DRAW
      ) :
        GgUniformBuffer<Light>(light, count, usage)
      {
      }

      ///
      /// 同じデータで埋めるコンストラクタ.
      ///
      /// @param light GgSimpleShader::Light 型の光源データ.
      /// @param count バッファ中の GgSimpleShader::Light 型の光源データの数.
      /// @param usage バッファの使い方のパターン, glBufferData() の第 4 引数の usage に渡される.
      ///
      LightBuffer(
        const Light& light,
        GLsizei count = 1,
        GLenum usage = GL_STATIC_DRAW
      ) :
        GgUniformBuffer<Light>(light, count, usage)
      {
      }

      ///
      /// デストラクタ.
      ///
      virtual ~LightBuffer()
      {
      }

      ///
      /// 光源の強度の環境光成分を設定する.
      ///
      /// @param r 光源の強度の環境光成分の赤成分.
      /// @param g 光源の強度の環境光成分の緑成分.
      /// @param b 光源の強度の環境光成分の青成分.
      /// @param a 光源の強度の拡散反射光成分の不透明度, デフォルトは 1.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadAmbient(
        GLfloat r, GLfloat g, GLfloat b, GLfloat a = 1.0f,
        GLint first = 0, GLsizei count = 1
      ) const;

      ///
      /// 光源の強度の環境光成分を設定する.
      ///
      /// @param ambient 光源の強度の環境光成分を格納した GgVector 型の変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadAmbient(const GgVector& ambient, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 光源の強度の環境光成分を設定する.
      ///
      /// @param ambient 光源の強度の環境光成分を格納した GLfloat 型の 4 要素の配列変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadAmbient(const GLfloat* ambient, GLint first = 0, GLsizei count = 1) const
      {
        // first 番目のブロックから count 個の ambient 要素に値を設定する
        send(ambient, offsetof(Light, ambient), sizeof(Light::ambient), first, count);
      }

      ///
      /// 光源の強度の拡散反射光成分を設定する.
      ///
      /// @param r 光源の強度の拡散反射光成分の赤成分.
      /// @param g 光源の強度の拡散反射光成分の緑成分.
      /// @param b 光源の強度の拡散反射光成分の青成分.
      /// @param a 光源の強度の拡散反射光成分の不透明度, デフォルトは 1.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadDiffuse(
        GLfloat r, GLfloat g, GLfloat b, GLfloat a = 1.0f,
        GLint first = 0, GLsizei count = 1
      ) const;

      ///
      /// 光源の強度の拡散反射光成分を設定する.
      ///
      /// @param specular 光源の強度の拡散反射光成分を格納した GgVector 型の変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadDiffuse(const GgVector& diffuse, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 光源の強度の拡散反射光成分を設定する.
      ///
      /// @param diffuse 光源の強度の拡散反射光成分を格納した GLfloat 型の 4 要素の配列変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadDiffuse(const GLfloat* diffuse, GLint first = 0, GLsizei count = 1) const
      {
        // first 番目のブロックから count 個の diffuse 要素に値を設定する
        send(diffuse, offsetof(Light, diffuse), sizeof(Light::diffuse), first, count);
      }

      ///
      /// 光源の強度の鏡面反射光成分を設定する.
      ///
      /// @param r 光源の強度の鏡面反射光成分の赤成分.
      /// @param g 光源の強度の鏡面反射光成分の緑成分.
      /// @param b 光源の強度の鏡面反射光成分の青成分.
      /// @param a 光源の強度の鏡面反射光成分の不透明度, デフォルトは 1.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadSpecular(
        GLfloat r, GLfloat g, GLfloat b, GLfloat a = 1.0f,
        GLint first = 0, GLsizei count = 1
      ) const;

      ///
      /// 光源の強度の鏡面反射光成分を設定する.
      ///
      /// @param specular 光源の強度の鏡面反射光成分を格納した GgVector 型の変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadSpecular(const GgVector& specular, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 光源の強度の鏡面反射光成分を設定する.
      ///
      /// @param specular 光源の強度の鏡面反射光成分を格納した GLfloat 型の 4 要素の配列変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadSpecular(const GLfloat* specular, GLint first = 0, GLsizei count = 1) const
      {
        // first 番目のブロックから count 個の specular 要素に値を設定する
        send(specular, offsetof(Light, specular), sizeof(Light::specular), first, count);
      }

      ///
      /// 光源の色を設定するが位置は変更しない.
      ///
      /// @param color 光源の特性の GgSimpleShader::Light 構造体.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadColor(const Light& color, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 光源の位置を設定する.
      ///
      /// @param x 光源の位置の x 座標.
      /// @param y 光源の位置の y 座標.
      /// @param z 光源の位置の z 座標.
      /// @param w 光源の位置の w 座標, デフォルトは 1.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadPosition(
        GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0f,
        GLint first = 0, GLsizei count = 1
      ) const;

      ///
      /// 光源の位置を設定する.
      ///
      /// @param position 光源の位置の同次座標を格納した GgVector 型の変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadPosition(const GgVector& position, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 光源の位置を設定する.
      ///
      /// @param position 光源の位置の同次座標を格納した GLfloat 型の 4 要素の配列変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadPosition(const GLfloat* position, GLint first = 0, GLsizei count = 1) const
      {
        // first 番目のブロックから count 個の position 要素に値を設定する
        send(position, offsetof(Light, position), sizeof(Light::position), first, count);
      }

      ///
      /// 光源の位置を設定する.
      ///
      /// @param position 光源の位置の同次座標を格納した GgVector 型の配列.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadPosition(const GgVector* position, GLint first = 0, GLsizei count = 1) const
      {
        loadPosition(position->data(), first, count);
      }

      ///
      /// 光源の色と位置を設定する.
      ///
      /// @param light 光源の特性の GgSimpleShader::Light 構造体のポインタ.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void load(const Light* light, GLint first = 0, GLsizei count = 1) const
      {
        send(light, 0, sizeof(Light), first, count);
      }

      ///
      /// 光源の色と位置を設定する.
      ///
      /// @param light 光源の特性の GgSimpleShader::Light 構造体.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void load(const Light& light, GLint first = 0, GLsizei count = 1) const
      {
        load(&light, first, count);
      }

      ///
      /// 光源を選択する.
      ///
      /// @param i 光源データの uniform block のインデックス.
      ///
      void select(GLint i = 0) const
      {
        // バッファオブジェクトの i 番目のブロックの位置
        const GLintptr offset(static_cast<GLintptr>(getStride()) * i);
        glBindBufferRange(getTarget(), LightBindingPoint, getBuffer(), offset, sizeof(Light));
      }
    };

    ///
    /// 三角形に単純な陰影付けを行うシェーダが参照する材質データ.
    ///
    struct Material
    {
      GgVector ambient;   ///< 環境光に対する反射係数.
      GgVector diffuse;   ///< 拡散反射係数.
      GgVector specular;  ///< 鏡面反射係数.
      GLfloat shininess;  ///< 輝き係数.
    };

    ///
    /// 三角形に単純な陰影付けを行うシェーダが参照する材質データのユニフォームバッファオブジェクト.
    ///
    class MaterialBuffer
      : public GgUniformBuffer<Material>
    {
    public:

      ///
      /// デフォルトコンストラクタ.
      ///
      /// @param material GgSimpleShader::Material 型の材質データのポインタ.
      /// @param count バッファ中の GgSimpleShader::Material 型の材質データの数.
      /// @param usage バッファの使い方のパターン, glBufferData() の第 4 引数の usage に渡される.
      ///
      MaterialBuffer(
        const Material* material = nullptr,
        GLsizei count = 1,
        GLenum usage = GL_STATIC_DRAW
      ) :
        GgUniformBuffer<Material>(material, count, usage)
      {
      }

      ///
      /// 同じデータで埋めるコンストラクタ.
      ///
      /// @param material GgSimpleShader::Material 型の材質データ.
      /// @param count バッファ中の GgSimpleShader::Material 型の材質データの数.
      /// @param usage バッファの使い方のパターン, glBufferData() の第 4 引数の usage に渡される.
      ///
      MaterialBuffer(
        const Material& material,
        GLsizei count = 1,
        GLenum usage = GL_STATIC_DRAW
      ) :
        GgUniformBuffer<Material>(material, count, usage)
      {
      }

      ///
      /// デストラクタ.
      ///
      virtual ~MaterialBuffer()
      {
      }

      ///
      /// 環境光に対する反射係数を設定する.
      ///
      /// @param r 環境光に対する反射係数の赤成分.
      /// @param g 環境光に対する反射係数の緑成分.
      /// @param b 環境光に対する反射係数の青成分.
      /// @param a 環境光に対する反射係数の不透明度, デフォルトは 1.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadAmbient(
        GLfloat r, GLfloat g, GLfloat b, GLfloat a = 1.0f,
        GLint first = 0, GLsizei count = 1
      ) const;

      ///
      /// 三角形に単純な陰影付けを行うシェーダが参照する光源データ：光源の強度の環境光成分を設定する.
      ///
      /// @param ambient 光源の強度の環境光成分を格納した GgVector 型の変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadAmbient(const GgVector& ambient, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 環境光に対する反射係数を設定する.
      ///
      /// @param ambient 環境光に対する反射係数を格納した GLfloat 型の 4 要素の配列変数.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadAmbient(const GLfloat* ambient, GLint first = 0, GLsizei count = 1) const
      {
        // first 番目のブロックから count 個のブロックの ambient 要素に値を設定する
        send(ambient, offsetof(Material, ambient), sizeof(Material::ambient), first, count);
      }

      ///
      /// 拡散反射係数を設定する.
      ///
      /// @param r 拡散反射係数の赤成分.
      /// @param g 拡散反射係数の緑成分.
      /// @param b 拡散反射係数の青成分.
      /// @param a 拡散反射係数の不透明度, デフォルトは 1.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadDiffuse(
        GLfloat r, GLfloat g, GLfloat b, GLfloat a = 1.0f,
        GLint first = 0, GLsizei count = 1
      ) const;

      ///
      /// 三角形に単純な陰影付けを行うシェーダが参照する光源データ：光源の強度の拡散反射光成分を設定する.
      ///
      /// @param ambient 光源の強度の拡散反射光成分を格納した GgVector 型の変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadDiffuse(const GgVector& diffuse, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 拡散反射係数を設定する.
      ///
      /// @param diffuse 拡散反射係数を格納した GLfloat 型の 4 要素の配列変数.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadDiffuse(const GLfloat* diffuse, GLint first = 0, GLsizei count = 1) const
      {
        // first 番目のブロックから count 個の diffuse 要素に値を設定する
        send(diffuse, offsetof(Material, diffuse), sizeof(Material::diffuse), first, count);
      }

      ///
      /// 環境光に対する反射係数と拡散反射係数を設定する.
      ///
      /// @param r 環境光に対する反射係数と拡散反射係数の赤成分.
      /// @param g 環境光に対する反射係数と拡散反射係数の緑成分.
      /// @param b 環境光に対する反射係数と拡散反射係数の青成分.
      /// @param a 環境光に対する反射係数と拡散反射係数の不透明度, デフォルトは 1.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadAmbientAndDiffuse(
        GLfloat r, GLfloat g, GLfloat b, GLfloat a = 1.0f,
        GLint first = 0, GLsizei count = 1
      ) const;

      ///
      /// 三角形に単純な陰影付けを行うシェーダが参照する材質データ：環境光に対する反射係数と拡散反射係数を設定する.
      ///
      /// @param color 環境光に対する反射係数と拡散反射係数を格納した GgVector 型の変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadAmbientAndDiffuse(const GgVector& color, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 環境光に対する反射係数と拡散反射係数を設定する.
      ///
      /// @param color 環境光に対する反射係数と拡散反射係数を格納した GLfloat 型の 4 要素の配列変数.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadAmbientAndDiffuse(const GLfloat* color, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 鏡面反射係数を設定する.
      ///
      /// @param r 鏡面反射係数の赤成分.
      /// @param g 鏡面反射係数の緑成分.
      /// @param b 鏡面反射係数の青成分.
      /// @param a 鏡面反射係数の不透明度, デフォルトは 1.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadSpecular(
        GLfloat r, GLfloat g, GLfloat b, GLfloat a = 1.0f,
        GLint first = 0, GLsizei count = 1
      ) const;

      ///
      /// 三角形に単純な陰影付けを行うシェーダが参照する材質データ：鏡面反射係数を設定する.
      ///
      /// @param ambient 鏡面反射係数を格納した GgVector 型の変数.
      /// @param first 値を設定する光源データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する光源データの数, デフォルトは 1.
      ///
      void loadSpecular(const GgVector& specular, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 鏡面反射係数を設定する.
      ///
      /// @param specular 鏡面反射係数を格納した GLfloat 型の 4 要素の配列変数.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadSpecular(const GLfloat* specular, GLint first = 0, GLsizei count = 1) const
      {
        // first 番目のブロックから count 個の specular 要素に値を設定する
        send(specular, offsetof(Material, specular), sizeof(Material::specular), first, count);
      }

      ///
      /// 輝き係数を設定する.
      ///
      /// @param shininess 輝き係数.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadShininess(GLfloat shininess, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 輝き係数を設定する.
      ///
      /// @param shininess 輝き係数.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void loadShininess(const GLfloat* shininess, GLint first = 0, GLsizei count = 1) const;

      ///
      /// 材質を設定する.
      ///
      /// @param material 光源の特性の GgSimpleShader::Material 構造体のポインタ.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void load(const Material* material, GLint first = 0, GLsizei count = 1) const
      {
        send(material, 0, sizeof(Material), first, count);
      }

      ///
      /// 材質を設定する.
      ///
      /// @param material 光源の特性の GgSimpleShader::Material 構造体.
      /// @param first 値を設定する材質データの最初の番号, デフォルトは 0.
      /// @param count 値を設定する材質データの数, デフォルトは 1.
      ///
      void load(const Material& material, GLint first = 0, GLsizei count = 1) const
      {
        load(&material, first, count);
      }

      ///
      /// 材質を選択する.
      ///
      /// @param i 材質データの uniform block のインデックス.
      ///
      void select(GLint i = 0) const
      {
        // バッファオブジェクトの i 番目のブロックの位置
        const GLintptr offset{ static_cast<GLintptr>(getStride()) * i };
        glBindBufferRange(getTarget(), MaterialBindingPoint, getBuffer(), offset, sizeof(Material));
      }
    };

    ///
    /// シェーダプログラムの使用を開始する.
    ///
    void use() const
    {
      // プログラムオブジェクトは基底クラスで指定する
      GgPointShader::use();
    }

    ///
    /// 投影変換行列とモデルビュー変換行列と法線変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    /// @param mn GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列の法線変換行列.
    ///
    void use(const GLfloat* mp, const GLfloat* mv, const GLfloat* mn) const
    {
      // プログラムオブジェクトを指定する
      use();

      // 変換行列を設定する
      loadMatrix(mp, mv, mn);
    }

    ///
    /// 投影変換行列とモデルビュー変換行列と法線変換行列を指定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    /// @param mn GgMatrix 型のモデルビュー変換行列の法線変換行列.
    ///
    void use(const GgMatrix& mp, const GgMatrix& mv, const GgMatrix& mn) const
    {
      use(mp.get(), mv.get(), mn.get());
    }

    ///
    /// 投影変換行列とモデルビュー変換行列を設定しモデルビュー変換行列から求めた法線変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    ///
    void use(const GLfloat* mp, const GLfloat* mv) const
    {
      use(mp, mv, GgMatrix(mv).normal().get());
    }

    ///
    /// 投影変換行列とモデルビュー変換行列を設定しモデルビュー変換行列から求めた法線変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    ///
    void use(const GgMatrix& mp, const GgMatrix& mv) const
    {
      use(mp, mv, mv.normal());
    }

    ///
    /// 光源を指定してシェーダプログラムの使用を開始する.
    ///
    /// @param light 光源の特性の gg::LightBuffer 構造体のポインタ.
    /// @param i 光源データの uniform block のインデックス.
    ///
    void use(const LightBuffer* light, GLint i = 0) const
    {
      // プログラムオブジェクトを指定する
      use();

      // 光源を設定する
      light->select(i);
    }

    ///
    /// 光源を指定してシェーダプログラムの使用を開始する.
    ///
    /// @param light 光源の特性の gg::LightBuffer 構造体.
    /// @param i 光源データの uniform block のインデックス.
    ///
    void use(const LightBuffer& light, GLint i = 0) const
    {
      use(&light, i);
    }

    ///
    /// 光源を指定し投影変換行列とモデルビュー変換行列と法線変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    /// @param mn GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列の法線変換行列.
    /// @param light 光源の特性の gg::LightBuffer 構造体のポインタ.
    /// @param i 光源データの uniform block のインデックス.
    ///
    void use(
      const GLfloat* mp,
      const GLfloat* mv,
      const GLfloat* mn,
      const LightBuffer* light,
      GLint i = 0
    ) const
    {
      // 光源を指定してプログラムオブジェクトを指定する
      use(light, i);

      // 変換行列を設定する
      loadMatrix(mp, mv, mn);
    }

    ///
    /// 光源を指定し投影変換行列とモデルビュー変換行列と法線変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    /// @param mn GgMatrix 型のモデルビュー変換行列の法線変換行列.
    /// @param light 光源の特性の gg::LightBuffer 構造体.
    /// @param i 光源データの uniform block のインデックス.
    ///
    void use(
      const GgMatrix& mp,
      const GgMatrix& mv,
      const GgMatrix& mn,
      const LightBuffer& light,
      GLint i = 0
    ) const
    {
      use(mp.get(), mv.get(), mn.get(), &light, i);
    }

    ///
    /// 光源を指定し投影変換行列とモデルビュー変換行列を設定しモデルビュー変換行列から求めた法線変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param mv GLfloat 型の 16 要素の配列変数に格納されたモデルビュー変換行列.
    /// @param light 光源の特性の gg::LightBuffer 構造体のポインタ.
    /// @param i 光源データの uniform block のインデックス.
    ///
    void use(
      const GLfloat* mp,
      const GLfloat* mv,
      const LightBuffer* light,
      GLint i = 0
    ) const
    {
      use(mp, mv, GgMatrix(mv).normal().get(), light, i);
    }

    ///
    /// 光源を指定し投影変換行列とモデルビュー変換行列を設定しモデルビュー変換行列から求めた法線変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param mv GgMatrix 型のモデルビュー変換行列.
    /// @param light 光源の特性の gg::LightBuffer 構造体.
    /// @param i 光源データの uniform block のインデックス.
    ///
    void use(
      const GgMatrix& mp,
      const GgMatrix& mv,
      const LightBuffer& light,
      GLint i = 0
    ) const
    {
      use(mp, mv, mv.normal(), light, i);
    }

    ///
    /// 光源を指定し投影変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GLfloat 型の 16 要素の配列変数に格納された投影変換行列.
    /// @param light 光源の特性の gg::LightBuffer 構造体のポインタ.
    /// @param i 光源データの uniform block のインデックス.
    ///
    void use(const GLfloat* mp, const LightBuffer* light, GLint i = 0) const
    {
      // 光源を指定してプログラムオブジェクトを指定する
      use(light, i);

      // 投影変換行列を設定する
      loadProjectionMatrix(mp);
    }

    ///
    /// 光源を指定し投影変換行列を設定してシェーダプログラムの使用を開始する.
    ///
    /// @param mp GgMatrix 型の投影変換行列.
    /// @param light 光源の特性の gg::LightBuffer 構造体.
    /// @param i 光源データの uniform block のインデックス.
    ///
    void use(const GgMatrix& mp, const LightBuffer& light, GLint i = 0) const
    {
      // 光源を指定してプログラムオブジェクトを指定する
      use(mp.get(), &light, i);
    }
  };

  ///
  /// 三角形分割された OBJ ファイルと MTL ファイルを読み込む (Arrays 形式)
  ///
  /// @param name 読み込む Wavefront OBJ ファイル名.
  /// @param group 読み込んだデータのポリゴングループごとの最初の三角形の番号と三角形数・材質番号.
  /// @param material 読み込んだデータのポリゴングループごとの GgSimpleShader::Material 型の材質.
  /// @param vert 読み込んだデータの頂点属性.
  /// @param normalize true なら読み込んだデータの大きさを正規化する.
  /// @return ファイルの読み込みに成功したら true.
  ///
  extern bool ggLoadSimpleObj(
    const std::string& name,
    std::vector<std::array<GLuint, 3>>& group,
    std::vector<GgSimpleShader::Material>& material,
    std::vector<GgVertex>& vert,
    bool normalize = false
  );

  ///
  /// 三角形分割された OBJ ファイルを読み込む (Elements 形式).
  ///
  /// @param name 読み込む Wavefront OBJ ファイル名.
  /// @param group 読み込んだデータのポリゴングループごとの最初の三角形の番号と三角形数・材質番号.
  /// @param material 読み込んだデータのポリゴングループごとの材質.
  /// @param vert 読み込んだデータの頂点属性.
  /// @param face 読み込んだデータの三角形の頂点インデックス.
  /// @param normalize true なら読み込んだデータの大きさを正規化する.
  /// @return ファイルの読み込みに成功したら true.
  ///
  extern bool ggLoadSimpleObj(
    const std::string& name,
    std::vector<std::array<GLuint, 3>>& group,
    std::vector<GgSimpleShader::Material>& material,
    std::vector<GgVertex>& vert,
    std::vector<GLuint>& face,
    bool normalize = false
  );

  ///
  /// Wavefront OBJ 形式のファイル (Arrays 形式).
  ///
  class GgSimpleObj
  {
    // 同じ材質を割り当てるポリゴングループごとの三角形数
    std::shared_ptr <std::vector<std::array<GLuint, 3>>> group;

    // ポリゴングループごとの材質のユニフォームバッファ
    std::shared_ptr<GgSimpleShader::MaterialBuffer> material;

    // この図形の形状データ
    std::shared_ptr<GgElements> data;

  public:

    ///
    /// コンストラクタ.
    ///
    /// @param name 三角形分割された Alias OBJ 形式のファイルのファイル名.
    /// @param normalize true なら図形のサイズを [-1, 1] に正規化する.
    ///
    GgSimpleObj(const std::string& name, bool normalize = false);

    ///
    /// デストラクタ.
    virtual ~GgSimpleObj()
    {
    }

    ///
    /// オブジェクトが有効かどうか調べる.
    ///
    /// @return オブジェクトが有効なら true
    ///
    explicit operator bool() const noexcept
    {
      return data.get() != nullptr;
    }

    ///
    /// オブジェクトが有効かどうかの結果を反転する.
    ///
    /// @return オブジェクトが有効なら false, 無効なら true.
    ///
    bool operator!() const noexcept
    {
      return !static_cast<bool>(*this);
    }

    ///
    /// 形状データの取り出し.
    ///
    /// @return GgTriangles 型の形状データのポインタ.
    ///
    const GgTriangles* get() const
    {
      return data.get();
    }

    ///
    /// Wavefront OBJ 形式のデータを描画する手続き.
    ///
    /// @param first 描画する最初のパーツ番号.
    /// @param count 描画するパーツの数, 0 なら全部のパーツを描く.
    ///
    virtual void draw(GLint first = 0, GLsizei count = 0) const;
  };
}
